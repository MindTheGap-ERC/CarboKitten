# The CarboKitten DSL

At some point in the evolution of CarboKitten, there will be many different implementations for production, disintegration, transport etc. Each with slightly different needs on the `Input` and `State` structures. Wouldn't it be cool if we could compose a model directly out of these components?

The CarboKitten **D**omain **S**pecific **L**anguage (DSL) is a way to compose models from their components a bit easier.

!!! info "Dangers of DRY"
    There is a danger here of which we should be aware: the **D**on't **R**epeat **Y**ourself (DRY) nomer is often taken a bit too far. The guiding principles are:

    - Don't write an overarching cathedral of an abstraction which may be invalidated some time in the future because of unforseen future requirements.
    - Stay close to the language primitives: with a bit of effort the code being generated by our DSL should be programmable by hand. We want to avoid boiler plate.
    - Stick to the aims:
        - reduce opportunities for making mistakes.
        - make our code self-documenting.

With that in mind: we implement a way in which groups of `struct` definitions can inherit in the most generic way applicable to our use case.

```@raw html
<details><summary>Boiler plate</summary>
```

``` {.julia file=test/DSLSpec.jl}
using CarboKitten.DSL
using MacroTools: prewalk, rmlines

clean(expr) = prewalk(rmlines, expr)

<<dsl-spec-defs>>

@testset "CarboKitten.DSL" begin
  <<dsl-spec>>
end
```

``` {.julia file=src/DSL.jl}
module DSL

include("DSL/Forward.jl")

using .Forward: @dynamic, @forward
using MacroTools: @capture, postwalk, prewalk
export @spec, @requires, @compose, @dynamic, @forward

<<dsl-struct-type>>

<<dsl>>

end
```

```@raw html
</details>
```

## First Example

The models in CarboKitten are all variations on a basic design. With the DSL we want to make it easy to swap model components without too much programming. This requires a method of composition that is not natively supported by the Julia language, however using some macros we can still get there.

The mini language we introduce here has three primitives: `@spec`, `@requires` and `@compose`.

``` {.julia}
using CarboKitten.DSL: @spec, @requires, @compose
```

The `@spec` syntax effectively does nothing else than creating a regular Julia module (a little bit more, just to make `@compose` work later on). This module will contain `struct` definitions and methods like you're used to.

``` {.julia}
@spec A begin
  mutable struct State
    a
  end

  step!(state) = ...
end
```

Now with a second spec `B`:

``` {.julia}
@spec B begin
  mutable struct State
    b
  end

  step!(state) = ...
end
```

We can now merge the two specs using `@compose`.

``` {.julia}
@compose C [A, B] begin
  using ..A
  using ..B

  step!(state) = begin
    A.step!(state)
    B.step!(state)
  end
end
```

This also creates a new module, but it will merge all struct definitions in the list of parents (`[A, B]` in this case). So the resulting code would look something like:

``` {.julia}
@compose C [A, B] begin
  using ..A
  using ..B

  mutable struct State
    a
    b
  end

  step!(state) = begin
    A.step!(state)
    B.step!(state)
  end
end
```

Notice, we still had to manually program the `step!` method, as there may be no clear way to merge such a method unambiguously. From this example it may still not be completely obvious why the `@spec`/`@compose` design gives us significant benifits.

First of all, in CarboKitten, both the `Input` and `State` data structures can get quite wieldy, and copying over large input data structures just to create variations of models can become cumbersome and error prone. This way, we can force models to keep consistent naming and structuring.

Second, if you look at the definition of the `C.step!(state)` method, notice that we could call `A.step!` and `B.step!` on the same data. This is always possible in Julia, because Julia is a dynamic language. Now however, when we change the interface in spec `A` we can trust that the composed model doesn't need to be changed with it.

Third, we can (yet to be implemented) automatically generate part of our documentation. Every model in CarboKitten will have an inheritance diagram showing exactly what components go into the model.

### Alternatives considered
Before going into alternatives, we should point out the peculiar properties of this system of inheritance:

- Non-hierarchical: the resulting `@compose`d struct definition really is just that: a struct containing all members from its parent definitions. Julia's dynamic type system does the rest for us. In the final composed model all types are completely known at compile time, making this solution efficient.
- Multiple inheritance: the basic nature of this system makes multiple inheritance trivial and this is what we want, since we're not really inheriting, we're composing.

#### Path not taken: Individual struct inheritance

Could be slightly simpler but ignores the way that different types have interplay, like `Input` and `State`. Having our model components represented as modules is a much cleaner solution.

#### Path not taken: Hierarchical composition

Often we see the nomer ["composition over inheritance"](https://en.wikipedia.org/wiki/Composition_over_inheritance) when it comes to object oriented programming. In most class based systems, this would mean that our composed state would look like this:

```julia
struct State
  a::A.State
  b::B.State
end
```

Then given some `x::State`, we would need to say `x.a.a` to access the element that was in `A.State`. A `@forward` macro can be constructed to reduce the indirection here.

This seems attractive, as it makes the composed state object easier to construct from its components, and also we can retrieve the original components by simple dereference. However, this betrays some old-fashioned thinking from the realm of staticly compiled languages: the idea that we then have a singly typed method that works for everyone (which is basically how OOP works in C++ and the likes).

The real problem comes when we compose from two specs that both have th same sub-spec (using the `@requires` syntax). Suddenly object construction becomes hard to implement (though not impossible). What becomes even harder though, is truly composed structs.

```julia
@spec A begin
    struct Facies
        a
    end

    struct Input
        facies::Facies
    end
end

@spec B begin
    struct Facies
        b
    end
end

@compose C [A, B] begin end
```

Now in module `A` we have some function expecting a type `A.Facies`. To get there, we now need to know that `C.Facies` also contains `A.Facies`. But how do we know that reasoning from the `Input` type? We could only reasonably do so by making sure `C.Facies` obeys the same interface as `A.Facies` and not type the functions in module `A` too strongly. This means we gained nothing from a lot of added complexity. Not typing functions too strongly is not the worst part. We couldn't even type the `Input.facies` member strongly, because really the `A.Input` struct now should contain a member of type `C.Facies`.

As it stands now, the above example works trivially, since the `@compose` macro only performs a (slightly fancy) code transformation. We still get "composition over inheritance", though the distinctioned becomes a bit blurred.

#### TODO Nested composition

It's a bit of a shame that composed models cannot be further composed, or that we have more symmetric notation. With future modifications it might be possible to get rid of this. Then all components would be given as items in a `@requires` statement.

Currently, `@spec` just stores the abstract syntax tree (AST) of a module inside that module and then `@compose` does all the mingling needed to insert the required structs in the final model.

The alternative: `@composing` and `@mixin`.

```julia
@composing module A
end

@composing module B
end

@composing module C
    @mixin A, B

    ...
end
```

The `@mixin` term comes from Ruby land.

#### Existing Julia libraries

- `Mixers.jl` works on a per struct basis, every definition creates a new macro making for a weird syntax.
- `ObjectOriented.jl` used for "classical" OOP, which does not apply here.

## Example: BS92

As a first example, let us recreate the [Bosscher1992](@cite) model. For this, we need to know the water depth, and specify a uniform production (i.e. without CA). First we define some units.

``` {.julia file=examples/dsl/bs92.jl}
using CarboKitten.DSL: @spec, @requires, @compose

module Units
  using Unitful
  using CarboKitten.Config: Box

  export Amount, Time, Height, Location, Rate, Intensity, Box, @u_str

  const Amount = typeof(1.0u"m")
  const Time = typeof(1.0u"Myr")
  const Height = typeof(1.0u"m")
  const Location = typeof(1.0u"km")
  const Rate = typeof(1.0u"m/Myr")
  const Intensity = typeof(1.0u"W/m^2")

  export AbstractInput, AbstractFacies, AbstractState

  abstract type AbstractInput end
  abstract type AbstractFacies end
  abstract type AbstractState end
end

<<dsl-example-time>>
<<dsl-example-waterdepth>>
<<dsl-example-production>>

@compose BS92 [UniformProduction] begin
  using CSV
  using DataFrames
  using Interpolations
  using CarboKitten.BoundaryTrait: Shelf
  using ..UniformProduction: uniform_production
  using ..TimeIntegration
  using ..WaterDepth

  # In the future, this function will be auto-generated
  function State(input::Input)
    ti_state = TimeIntegration.State(input)
    wd_state = WaterDepth.State(input)
    return State(ti_state.time, wd_state.sediment_height)
  end

  function step(input::Input)
    τ = uniform_production(input)
    function (state::State)
      Δη = sum(τ(state); dims=1)[1,:,:] .* input.time.Δt
      state.sediment_height .+= Δη
      state.time += input.time.Δt
    end
  end

  function sealevel_curve()
       data = DataFrame(CSV.File("data/bs92-sealevel-curve.csv"))
       linear_interpolation(data.time, data.depth)
  end

  const INPUT = Input(
      box = Box{Shelf}(grid_size=(100, 1), phys_scale=600.0u"m"),
      time = TimeProperties(
        Δt = 10.0u"yr",
        steps = 8000,
        write_interval = 100),
      sea_level = let sc = sealevel_curve()
        t -> -sc(t / u"yr") * u"m"
      end,
      bedrock_elevation = (x, y) -> - x / 300.0,
      subsidence_rate = 0.0u"m/yr",
      insolation = 400.0u"W/m^2",
      facies = [Facies(
        maximum_growth_rate = 0.005u"m/yr",
        saturation_intensity = 50.0u"W/m^2",
        extinction_coefficient = 0.05u"m^-1"
      )])

  function run(input::Input)
      step! = step(input)
      getwd = WaterDepth.water_depth(input)
      state = State(input)

      n_writes = input.time.steps ÷ input.time.write_interval
      result = Array{Amount, 2}(undef, input.box.grid_size[1], n_writes)
      wd = Array{Amount, 2}(undef, input.box.grid_size[1], n_writes)
      for i = 1:n_writes
        wd[:,i] = getwd(state)
        for _ = 1:input.time.write_interval
              step!(state)
          end
          result[:,i] = state.sediment_height[:,1]
      end
      return result, wd
  end
end

using GLMakie
using CarboKitten.Utility: in_units_of
using CarboKitten.Config: axes as box_axes
using Unitful

function main()
  result, wd = BS92.run(BS92.INPUT)
  fig = Figure()
  ax = Axis(fig[1,1], xlabel="x (km)", ylabel="z (m)")
  x, y = box_axes(BS92.INPUT.box)
  η0 = BS92.INPUT.bedrock_elevation.(x, y')

  for l in eachcol(result)
    η = η0 .+ l
    lines!(ax, x |> in_units_of(u"km"), vec(η) |> in_units_of(u"m"), color=:steelblue4)
  end

  fig
end

main()
```

### Time

``` {.julia #dsl-example-time}
@spec TimeIntegration begin
  using ..Units
  using CarboKitten.Config: TimeProperties

  @kwdef struct Input <: AbstractInput
    time::TimeProperties
  end

  mutable struct State <: AbstractState
    time::Time
  end

  State(input::AbstractInput) = State(0.0u"Myr")
end
```

### Water depth
``` {.julia #dsl-example-waterdepth}
@spec WaterDepth begin
  @requires TimeIntegration
  using ..Units
  using CarboKitten.Config: axes

  @kwdef struct Input <: AbstractInput
    box::Box
    sea_level          # function (t::Time) -> Length
    bedrock_elevation  # function (x::Location, y::Location) -> Length
    subsidence_rate::Rate
  end

  mutable struct State <: AbstractState
    sediment_height::Matrix{Height}
  end

  State(input::AbstractInput) = State(zeros(Height, input.box.grid_size...))

  function water_depth(input::AbstractInput)
    x, y = axes(input.box)
    eta0 = input.bedrock_elevation.(x, y')

    return function(state::AbstractState)
      return input.sea_level(state.time) .- eta0 .+
        (input.subsidence_rate * state.time) .- state.sediment_height
    end
  end
end
```

### Uniform Production

``` {.julia #dsl-example-production}
@spec UniformProduction begin
  @requires WaterDepth
  using ..Units
  using ..WaterDepth: water_depth

  @kwdef struct Facies <: AbstractFacies
    maximum_growth_rate::Rate
    extinction_coefficient::typeof(1.0u"m^-1")
    saturation_intensity::Intensity
  end

  @kwdef struct Input <: AbstractInput
    insolation::Intensity
    facies::Vector{Facies}
  end

  function production_rate(insolation, facies, water_depth)
      gₘ = facies.maximum_growth_rate
      I = insolation / facies.saturation_intensity
      x = water_depth * facies.extinction_coefficient
      return water_depth > 0.0u"m" ? gₘ * tanh(I * exp(-x)) : 0.0u"m/Myr"
  end

  function uniform_production(input::AbstractInput)
    w = water_depth(input)
    na = [CartesianIndex()]

    return function(state::AbstractState)
      return production_rate.(
        input.insolation,
        input.facies[:,na,na],
        w(state)[na,:,:])
    end
  end
end
```

## Implementation
### `@forward`

The `@forward` macro is not at the front of our DSL, rather a method of inheritance for structs that leads up to the DSL. One of the oft repeated answers to the question "why doesn't Julia have OOP?" is: compose don't inherit. What we'll do is inherit through composition. That way it is also easier to down-cast an object.

``` {.julia #dsl-spec-defs}
struct Parent
  x::Int
end

struct Child
  p::Parent
  y::Int
end

@dynamic Child
@forward Child.x ~ Child.p.x
```

``` {.julia #dsl-spec}
let c = Child(Parent(42), 23)
@assert c.x == 42
@assert c.y == 23
end
```

The amount of `$(esc(:blah))` expressions make this code impossible to read. Not sure if there's ways to reduce those.

``` {.julia file=src/DSL/Forward.jl}
module Forward

using MacroTools: @capture, postwalk, prewalk
import Base: getproperty, setproperty!

struct Field{Sym} end

function define_dynamic(class::Symbol)
    getter = Symbol(lowercase(string(class)), "_get")
    setter = Symbol(lowercase(string(class)), "_set!")
    :(begin
        $(esc(getter))(self::$(esc(class)), ::$(esc(:Type)){Field{symb}}) where {symb} =
            $(esc(:(Core.getfield)))(self, symb)
        $(esc(setter))(self::$(esc(class)), ::$(esc(:Type)){Field{symb}}, value) where {symb} =
            $(esc(:(Core.setfield!)))(self, symb, value)
        $(esc(:(Base.getproperty)))(self::$(esc(class)), symb::Symbol) =
            $(esc(getter))(self, Field{symb})
        $(esc(:(Base.setproperty!)))(self::$(esc(class)), symb::Symbol, value) =
            $(esc(setter))(self, Field{symb}, value)
    end)
end

function get_path_expr(path...)
    foldl((s, f) -> :($(esc(:(Core.getfield)))($s, $(Expr(:quote, f)))), path)
end

function define_forward(class::Symbol, name::Symbol, path::Tuple)
    getter = Symbol(lowercase(string(class)), "_get")
    setter = Symbol(lowercase(string(class)), "_set!")
    :(begin
        $(esc(getter))(self::$(esc(class)), ::$(esc(:Type)){Field{$(Expr(:quote, name))}}) =
            $(get_path_expr(:self, path...))
        $(esc(setter))(self::$(esc(class)), ::$(esc(:Type)){Field{$(Expr(:quote, name))}}, value) =
            $(esc(:(Core.setfield!)))($(get_path_expr(:self, Base.front(path)...)), $(Expr(:quote, last(path))), value)
    end)
end

macro dynamic(class)
    define_dynamic(class)
end

function get_path(expr)
    if @capture(expr, a_.b_)
        return (get_path(a)..., b)
    else
        return (expr,)
    end
end

macro forward(expr)
    @assert @capture(expr, fwd_ ~ path_)
    @assert @capture(fwd, class_.field_)
    define_forward(class, field, Base.tail(get_path(path)))
end

end
```


### `@spec`

The `@spec` macro stores a spec syntax in a newly created module.

``` {.julia #dsl-spec-defs}
@spec MySpec begin
    const msg = "hello"
end
```

``` {.julia #dsl-spec}
@test clean(MySpec.AST) == clean(:(begin const msg = "hello" end))
@test MySpec.msg == "hello"
```

The `@spec` macro is used to specify the structs of a model component.

``` {.julia #dsl}
"""
    @spec name body

Create a spec. When a spec is composed, the items in the spec will be spliced into a newly generated module. The `@spec` macro itself doesn't perform any operations other than storing the spec in a `const` expression. The real magic happens inside the `@compose` macro.
"""
macro spec(name, body)
    quoted_body = QuoteNode(body)

    clean_body = postwalk(e -> @capture(e, @requires parents__) ? :() : e, body)
    esc(Expr(:toplevel, :(module $name
        $(clean_body.args...)
        const AST = $quoted_body
    end)))
end

macro requires(deps...)
    esc(:(const PARENTS = [$(deps)...]))
end
```

### `@compose`

The idea of `@compose` is that it splices `struct` definitions, such that resulting structs contain all members from required specs.

We define some variables to collect structs, consts and `using` declarations. At the end we use these collections to build a new module.

``` {.julia #dsl-spec-defs}
@spec A begin
  struct S
    a::Int
  end
end

@spec B begin
  struct S
    b::Int
  end
end

@compose AB [A, B] begin
end
```

``` {.julia #dsl-spec}
@test fieldnames(AB.S) == (:a, :b)
```

A spec can depend on another using the `@require` syntax.

``` {.julia #dsl-spec-defs}
@spec C begin
  @requires A
  struct S
    c::Int
  end

  @kwdef struct T
    f::Int
  end
end

@compose AC [C] begin
end
```

``` {.julia #dsl-spec}
@test fieldnames(AC.S) == (:a, :c)
@test fieldnames(AC.T) == (:f,)
@test AC.T(f = 4).f == 4
```

```@raw html
<details><summary>`@compose` implementation</summary>
```

``` {.julia #dsl}
macro compose(modname, cs, body)
    components = Set{Symbol}()

    structs = IdDict()
    using_statements = []
    const_statements = []
    specs_used = Set()

    <<dsl-compose>>

    @assert cs.head == :vect
    cs.args .|> scan

    Expr(:toplevel, esc(:(module $modname
        $(using_statements...)
        $(const_statements...)
        $(Iterators.map(splat(define_struct), pairs(structs))...)
        $(body.args...)
    end)))
end
```

``` {.julia #dsl-compose}
function extend_struct!(name::Symbol, fields::Vector)
    append!(structs[name].fields, fields)
end

function create_struct!(name::Symbol, is_mutable::Bool, is_kwarg::Bool, abst::Union{Symbol, Nothing}, fields::Vector)
    structs[name] = Struct(is_mutable, is_kwarg, abst, fields)
end

function pass(e)
    if @capture(e, @requires parents__)
        parents .|> scan
        return
    end

    if @capture(e, (struct name_ fields__ end) |
                   (@kwdef struct kw_name_ fields__ end) |
                   (mutable struct mut_name_ fields__ end))
        is_mutable = mut_name !== nothing
        is_kwarg = kw_name !== nothing
        sname = is_mutable ? mut_name : (is_kwarg ? kw_name : name)

        @capture(sname, (name_ <: abst_) | name_)

        if name in keys(structs)
            extend_struct!(name, fields)
        else
            create_struct!(name, is_mutable, is_kwarg, abst, fields)
        end
        return
    end

    if @capture(e, const n_ = x_)
        push!(const_statements, e)
        return
    end

    if @capture(e, using x__ | using mod__: x__)
        push!(using_statements, e)
        return
    end

    return e
end

function scan(c::Symbol)
    if c in specs_used
        return
    end
    push!(specs_used, c)

    e = Core.eval(__module__, :($(c).AST))
    prewalk(pass, e)
end
```

``` {.julia #dsl-struct-type}
struct Struct
    mut::Bool
    kwarg::Bool
    parent::Union{Symbol, Nothing}
    fields::Vector{Union{Expr,Symbol}}
end

function define_struct(name::Symbol, s::Struct)
    if s.parent !== nothing
        name = :($name <: $(s.parent))
    end
    if s.mut
        :(mutable struct $name
            $(s.fields...)
        end)
    elseif s.kwarg
        :(@kwdef struct $name
            $(s.fields...)
          end)
    else
        :(struct $name
            $(s.fields...)
        end)
    end
end
```

```@raw html
</details>
```
