# The CarboKitten DSL

At some point in the evolution of CarboKitten, there will be many different implementations for production, disintegration, transport etc. Each with slightly different needs on the `Input` and `State` structures. Wouldn't it be cool if we could compose a model directly out of these components?

The CarboKitten **D**omain **S**pecific **L**anguage (DSL) is a way to compose models from their components a bit easier.

!!! info "Dangers of DRY"
    There is a danger here of which we should be aware: the **D**on't **R**epeat **Y**ourself (DRY) nomer is often taken a bit too far. The guiding principles are:

    - Don't write an overarching cathedral of an abstraction which may be invalidated some time in the future because of unforseen future requirements.
    - Stay close to the language primitives: with a bit of effort the code being generated by our DSL should be programmable by hand. We want to avoid boiler plate.
    - Stick to the aims:
        - reduce opportunities for making mistakes.
        - make our code self-documenting.

With that in mind: we implement a way in which groups of `struct` definitions can inherit in the most generic way applicable to our use case.

```@raw html
<details><summary>Boiler plate</summary>
```

``` {.julia file=test/DSLSpec.jl}
using CarboKitten.DSL
using MacroTools: prewalk, rmlines

clean(expr) = prewalk(rmlines, expr)

<<dsl-spec-defs>>

@testset "CarboKitten.DSL" begin
  <<dsl-spec>>
end
```

``` {.julia file=src/DSL.jl}
module DSL

include("DSL/Forward.jl")

using .Forward: @dynamic, @forward
using MacroTools: @capture, postwalk, prewalk
export @spec, @requires, @compose, @dynamic, @forward

<<dsl-struct-type>>

<<dsl>>

end
```

```@raw html
</details>
```

## Example

As a first example, let us recreate the [Bosscher1992](@cite) model. For this, we need to know the water depth, and specify a uniform production (i.e. without CA). First we define some units.

``` {.julia file=examples/dsl/bs92.jl}
using CarboKitten.DSL: @spec, @requires, @compose

module Units
  using Unitful
  using CarboKitten.Config: Box

  export Amount, Time, Height, Location, Rate, Intensity, Box, @u_str

  const Amount = typeof(1.0u"m")
  const Time = typeof(1.0u"Myr")
  const Height = typeof(1.0u"m")
  const Location = typeof(1.0u"km")
  const Rate = typeof(1.0u"m/Myr")
  const Intensity = typeof(1.0u"W/m^2")

  export AbstractInput, AbstractFacies, AbstractState

  abstract type AbstractInput end
  abstract type AbstractFacies end
  abstract type AbstractState end
end

<<dsl-example-time>>
<<dsl-example-waterdepth>>
<<dsl-example-production>>

@compose BS92 [UniformProduction] begin
  using CSV
  using DataFrames
  using Interpolations
  using CarboKitten.BoundaryTrait: Shelf
  using ..UniformProduction: uniform_production
  using ..TimeIntegration
  using ..WaterDepth

  # In the future, this function will be auto-generated
  function State(input::Input)
    ti_state = TimeIntegration.State(input)
    wd_state = WaterDepth.State(input)
    return State(ti_state.time, wd_state.sediment_height)
  end

  function step(input::Input)
    τ = uniform_production(input)
    function (state::State)
      Δη = sum(τ(state); dims=1)[1,:,:] .* input.time.Δt
      state.sediment_height .+= Δη
      state.time += input.time.Δt
    end
  end

  function sealevel_curve()
       data = DataFrame(CSV.File("data/bs92-sealevel-curve.csv"))
       linear_interpolation(data.time, data.depth)
  end

  const INPUT = Input(
      box = Box{Shelf}(grid_size=(100, 1), phys_scale=600.0u"m"),
      time = TimeProperties(
        Δt = 10.0u"yr",
        steps = 8000,
        write_interval = 100),
      sea_level = let sc = sealevel_curve()
        t -> -sc(t / u"yr") * u"m"
      end,
      bedrock_elevation = (x, y) -> - x / 300.0,
      subsidence_rate = 0.0u"m/yr",
      insolation = 400.0u"W/m^2",
      facies = [Facies(
        maximum_growth_rate = 0.005u"m/yr",
        saturation_intensity = 50.0u"W/m^2",
        extinction_coefficient = 0.05u"m^-1"
      )])

  function run(input::Input)
      step! = step(input)
      getwd = WaterDepth.water_depth(input)
      state = State(input)

      n_writes = input.time.steps ÷ input.time.write_interval
      result = Array{Amount, 2}(undef, input.box.grid_size[1], n_writes)
      wd = Array{Amount, 2}(undef, input.box.grid_size[1], n_writes)
      for i = 1:n_writes
        wd[:,i] = getwd(state)
        for _ = 1:input.time.write_interval
              step!(state)
          end
          result[:,i] = state.sediment_height[:,1]
      end
      return result, wd
  end
end

using GLMakie
using CarboKitten.Utility: in_units_of
using CarboKitten.Config: axes as box_axes
using Unitful

function main()
  result, wd = BS92.run(BS92.INPUT)
  fig = Figure()
  ax = Axis(fig[1,1], xlabel="x (km)", ylabel="z (m)")
  x, y = box_axes(BS92.INPUT.box)
  η0 = BS92.INPUT.bedrock_elevation.(x, y')

  for l in eachcol(result)
    η = η0 .+ l
    lines!(ax, x |> in_units_of(u"km"), vec(η) |> in_units_of(u"m"), color=:steelblue4)
  end

  fig
end

main()
```

### Time

``` {.julia #dsl-example-time}
@spec TimeIntegration begin
  using ..Units
  using CarboKitten.Config: TimeProperties

  @kwdef struct Input <: AbstractInput
    time::TimeProperties
  end

  mutable struct State <: AbstractState
    time::Time
  end

  State(input::AbstractInput) = State(0.0u"Myr")
end
```

### Water depth
``` {.julia #dsl-example-waterdepth}
@spec WaterDepth begin
  @requires TimeIntegration
  using ..Units
  using CarboKitten.Config: axes

  @kwdef struct Input <: AbstractInput
    box::Box
    sea_level          # function (t::Time) -> Length
    bedrock_elevation  # function (x::Location, y::Location) -> Length
    subsidence_rate::Rate
  end

  mutable struct State <: AbstractState
    sediment_height::Matrix{Height}
  end

  State(input::AbstractInput) = State(zeros(Height, input.box.grid_size...))

  function water_depth(input::AbstractInput)
    x, y = axes(input.box)
    eta0 = input.bedrock_elevation.(x, y')

    return function(state::AbstractState)
      return input.sea_level(state.time) .- eta0 .+
        (input.subsidence_rate * state.time) .- state.sediment_height
    end
  end
end
```

### Uniform Production

``` {.julia #dsl-example-production}
@spec UniformProduction begin
  @requires WaterDepth
  using ..Units
  using ..WaterDepth: water_depth

  @kwdef struct Facies <: AbstractFacies
    maximum_growth_rate::Rate
    extinction_coefficient::typeof(1.0u"m^-1")
    saturation_intensity::Intensity
  end

  @kwdef struct Input <: AbstractInput
    insolation::Intensity
    facies::Vector{Facies}
  end

  function production_rate(insolation, facies, water_depth)
      gₘ = facies.maximum_growth_rate
      I = insolation / facies.saturation_intensity
      x = water_depth * facies.extinction_coefficient
      return water_depth > 0.0u"m" ? gₘ * tanh(I * exp(-x)) : 0.0u"m/Myr"
  end

  function uniform_production(input::AbstractInput)
    w = water_depth(input)
    na = [CartesianIndex()]

    return function(state::AbstractState)
      return production_rate.(
        input.insolation,
        input.facies[:,na,na],
        w(state)[na,:,:])
    end
  end
end
```

## `@forward`

The `@forward` macro is not at the front of our DSL, rather a method of inheritance for structs that leads up to the DSL. One of the oft repeated answers to the question "why doesn't Julia have OOP?" is: compose don't inherit. What we'll do is inherit through composition. That way it is also easier to down-cast an object.

``` {.julia #dsl-spec-defs}
struct Parent
  x::Int
end

struct Child
  p::Parent
  y::Int
end

@dynamic Child
@forward Child.x ~ Child.p.x
```

``` {.julia #dsl-spec}
let c = Child(Parent(42), 23)
@assert c.x == 42
@assert c.y == 23
end
```

The amount of `$(esc(:blah))` expressions make this code impossible to read. Not sure if there's ways to reduce those.

``` {.julia file=src/DSL/Forward.jl}
module Forward

using MacroTools: @capture, postwalk, prewalk
import Base: getproperty, setproperty!

struct Field{Sym} end

function define_dynamic(class::Symbol)
    getter = Symbol(lowercase(string(class)), "_get")
    setter = Symbol(lowercase(string(class)), "_set!")
    :(begin
        $(esc(getter))(self::$(esc(class)), ::$(esc(:Type)){Field{symb}}) where {symb} =
            $(esc(:(Core.getfield)))(self, symb)
        $(esc(setter))(self::$(esc(class)), ::$(esc(:Type)){Field{symb}}, value) where {symb} =
            $(esc(:(Core.setfield!)))(self, symb, value)
        $(esc(:(Base.getproperty)))(self::$(esc(class)), symb::Symbol) =
            $(esc(getter))(self, Field{symb})
        $(esc(:(Base.setproperty!)))(self::$(esc(class)), symb::Symbol, value) =
            $(esc(setter))(self, Field{symb}, value)
    end)
end

function get_path_expr(path...)
    foldl((s, f) -> :($(esc(:(Core.getfield)))($s, $(Expr(:quote, f)))), path)
end

function define_forward(class::Symbol, name::Symbol, path::Tuple)
    getter = Symbol(lowercase(string(class)), "_get")
    setter = Symbol(lowercase(string(class)), "_set!")
    :(begin
        $(esc(getter))(self::$(esc(class)), ::$(esc(:Type)){Field{$(Expr(:quote, name))}}) =
            $(get_path_expr(:self, path...))
        $(esc(setter))(self::$(esc(class)), ::$(esc(:Type)){Field{$(Expr(:quote, name))}}, value) =
            $(esc(:(Core.setfield!)))($(get_path_expr(:self, Base.front(path)...)), $(Expr(:quote, last(path))), value)
    end)
end

macro dynamic(class)
    define_dynamic(class)
end

function get_path(expr)
    if @capture(expr, a_.b_)
        return (get_path(a)..., b)
    else
        return (expr,)
    end
end

macro forward(expr)
    @assert @capture(expr, fwd_ ~ path_)
    @assert @capture(fwd, class_.field_)
    define_forward(class, field, Base.tail(get_path(path)))
end

end
```


## `@spec`

The `@spec` macro stores a spec syntax in a newly created module.

``` {.julia #dsl-spec-defs}
@spec MySpec begin
    const msg = "hello"
end
```

``` {.julia #dsl-spec}
@test clean(MySpec.AST) == clean(:(begin const msg = "hello" end))
@test MySpec.msg == "hello"
```

The `@spec` macro is used to specify the structs of a model component.

``` {.julia #dsl}
"""
    @spec name body

Create a spec. When a spec is composed, the items in the spec will be spliced into a newly generated module. The `@spec` macro itself doesn't perform any operations other than storing the spec in a `const` expression. The real magic happens inside the `@compose` macro.
"""
macro spec(name, body)
    quoted_body = QuoteNode(body)

    clean_body = postwalk(e -> @capture(e, @requires parents__) ? :() : e, body)
    esc(Expr(:toplevel, :(module $name
        $(clean_body.args...)
        const AST = $quoted_body
    end)))
end

macro requires(deps...)
    esc(:(const PARENTS = [$(deps)...]))
end
```

## `@compose`

The idea of `@compose` is that it splices `struct` definitions, such that resulting structs contain all members from required specs.

We define some variables to collect structs, consts and `using` declarations. At the end we use these collections to build a new module.

``` {.julia #dsl-spec-defs}
@spec A begin
  struct S
    a::Int
  end
end

@spec B begin
  struct S
    b::Int
  end
end

@compose AB [A, B] begin
end
```

``` {.julia #dsl-spec}
@test fieldnames(AB.S) == (:a, :b)
```

A spec can depend on another using the `@require` syntax.

``` {.julia #dsl-spec-defs}
@spec C begin
  @requires A
  struct S
    c::Int
  end

  @kwdef struct T
    f::Int
  end
end

@compose AC [C] begin
end
```

``` {.julia #dsl-spec}
@test fieldnames(AC.S) == (:a, :c)
@test fieldnames(AC.T) == (:f,)
@test AC.T(f = 4).f == 4
```

```@raw html
<details><summary>`@compose` implementation</summary>
```

``` {.julia #dsl}
macro compose(modname, cs, body)
    components = Set{Symbol}()

    structs = IdDict()
    using_statements = []
    const_statements = []
    specs_used = Set()

    <<dsl-compose>>

    @assert cs.head == :vect
    cs.args .|> scan

    Expr(:toplevel, esc(:(module $modname
        $(using_statements...)
        $(const_statements...)
        $(Iterators.map(splat(define_struct), pairs(structs))...)
        $(body.args...)
    end)))
end
```

``` {.julia #dsl-compose}
function extend_struct!(name::Symbol, fields::Vector)
    append!(structs[name].fields, fields)
end

function create_struct!(name::Symbol, is_mutable::Bool, is_kwarg::Bool, abst::Union{Symbol, Nothing}, fields::Vector)
    structs[name] = Struct(is_mutable, is_kwarg, abst, fields)
end

function pass(e)
    if @capture(e, @requires parents__)
        parents .|> scan
        return
    end

    if @capture(e, (struct name_ fields__ end) |
                   (@kwdef struct kw_name_ fields__ end) |
                   (mutable struct mut_name_ fields__ end))
        is_mutable = mut_name !== nothing
        is_kwarg = kw_name !== nothing
        sname = is_mutable ? mut_name : (is_kwarg ? kw_name : name)

        @capture(sname, (name_ <: abst_) | name_)

        if name in keys(structs)
            extend_struct!(name, fields)
        else
            create_struct!(name, is_mutable, is_kwarg, abst, fields)
        end
        return
    end

    if @capture(e, const n_ = x_)
        push!(const_statements, e)
        return
    end

    if @capture(e, using x__ | using mod__: x__)
        push!(using_statements, e)
        return
    end

    return e
end

function scan(c::Symbol)
    if c in specs_used
        return
    end
    push!(specs_used, c)

    e = Core.eval(__module__, :($(c).AST))
    prewalk(pass, e)
end
```

``` {.julia #dsl-struct-type}
struct Struct
    mut::Bool
    kwarg::Bool
    parent::Union{Symbol, Nothing}
    fields::Vector{Union{Expr,Symbol}}
end

function define_struct(name::Symbol, s::Struct)
    if s.parent !== nothing
        name = :($name <: $(s.parent))
    end
    if s.mut
        :(mutable struct $name
            $(s.fields...)
        end)
    elseif s.kwarg
        :(@kwdef struct $name
            $(s.fields...)
          end)
    else
        :(struct $name
            $(s.fields...)
        end)
    end
end
```

```@raw html
</details>
```

## Some types

``` {.julia #types}

abstract type Input end
abstract type State end
abstract type Facies end
```
