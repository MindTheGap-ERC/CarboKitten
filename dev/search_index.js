var documenterSearchIndex = {"docs":
[{"location":"unitful/#Unitful","page":"Unitful","title":"Unitful","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Physical quantities in CarboKitten are always specified using the Unitful.jl framework.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">file:<i>test/Unitful.jl</i></div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@testset \"Unitful\" begin\n    using Unitful\n    using Unitful.DefaultSymbols\n    using CarboKitten.Utility\n\n    <<unitful-spec>>\nend","category":"page"},{"location":"unitful/#Variables-vs.-string-macros","page":"Unitful","title":"Variables vs. string macros","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Unitful package offers two basic ways to enter quantities: either using predefined symbols (polluting your namespace with one-letter variables), or using special string macros.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@test 1.0m === 1.0u\"m\"\n@test 42J/s == 42u\"W\"","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"In many cases, your CarboKitten scripts will contain little else than the input specification. In such a case using Unitful.DefaultSymbols gives a bit cleaner, more readable look.","category":"page"},{"location":"unitful/#Reading-specs","page":"Unitful","title":"Reading specs","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Suppose we simulate a pendulum. We would have an input spec defined as follows:","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚äû</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@kwdef struct Pendulum\n    length :: typeof(1.0m)\n    time_step :: typeof(1.0s)\n    phi0 :: typeof(1.0rad)\n    omega0 :: typeof(1.0rad/s)\nend","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Then input can be given as follows:","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚äû</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"pendulum = Pendulum(\n    length = 2.0m,\n    time_step = 1ms,\n    phi0 = 30¬∞,\n    omega0 = 0rad/s\n)","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Units are automatically converted to the types specified in the API.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚äû</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@test pendulum.time_step === 0.001s\n@test pendulum.phi0 === (œÄ/6)rad","category":"page"},{"location":"unitful/#Dimensions","page":"Unitful","title":"Dimensions","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Unitful has dimensions of length ùêã, mass ùêå and time ùêì as bold upper-case Unicode symbols. These can be entered in Julia with \\bfL, \\bfM etc. When you define a function that needs, say, an energy, which has SI units of rm J = (ms)^2 kg, we can construct the dimensions. Defining a few constants:","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚äû</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"let ùêÑ = (ùêã/ùêì)^2 * ùêå,\n    h = 6.62607015e-34u\"J*s\",\n    c = 299792458u\"m/s\"\n    <<unitful-photon-example>>\nend","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"We can abstract over the specific units by defining a generic method. Now we can compute the wavelength of a photon, given its energy in any unit of energy.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-photon-example‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"photon_wave_length(E::Quantity{Float64,ùêÑ,J}) where {J} =\n    uconvert(u\"‚Ñ´\", h * c / E)\n\n@test photon_wave_length(2.38u\"eV\") ‚âà 5209.4201u\"‚Ñ´\"\n@test_throws MethodError photon_wave_length(1u\"m\")","category":"page"},{"location":"unitful/#Negating-Units","page":"Unitful","title":"Negating Units","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"There is a handy way of negating units (getting back to raw scalars) using the NoUnits function object.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚äû</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@test 23u\"km\" / u\"m\" |> NoUnits == 23000","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Now, suppose we have a Vector of which we don't know the exact units, but we want to save values in meters to HDF5. When we get a vector in meters, and divide by u\"m\", Unitful will simplify and return a plain Vector{Float64}. However, if the units were u\"km\", then we need to convert by multiplying by 1000. We could do vec .|> NoUnits, but this will always allocate a new vector, even when it is not needed. We have the short-hand in_units_of that solves this issue.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚äû</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@test 23u\"km\" |> in_units_of(u\"m\") == 23000\n@test [4, 5, 6]u\"m\" |> in_units_of(u\"m\") == [4, 5, 6]","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°utility‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"function in_units_of(unit)\n    function magnitude(a::AbstractArray{Quantity{RT, NoDims, U}, dim}) where {RT <: Real, U, dim}\n        return a .|> NoUnits\n    end\n\n    function magnitude(a::AbstractArray{RT, dim}) where {RT <: Real, dim}\n        return a\n    end\n\n    function magnitude(a::RT) where {RT <: Real}\n        return a\n    end\n\n    function magnitude(a::Quantity{RT, NoDims, U}) where {RT <: Real, U}\n        return a |> NoUnits\n    end\n\n    function (x)\n        x / unit |> magnitude\n    end\nend","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#title:-References","page":"References","title":"title: References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<div class=\"citation canonical\"><dl><dt>[1]</dt>\n<dd>\n<div id=\"Bosscher1992\">H. Bosscher and W. Schlager. <i>Computer simulation of reef growth</i>. Sedimentology <b>39</b>, 503‚Äì512 (1992).</div>\n</dd>\n</dl></div>","category":"page"},{"location":"bs92-w-erosion/#Bosscher-and-Schlager-model-with-erosion","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"","category":"section"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"<div class=\"noweb-label\">file:<i>src/Erosion.jl</i></div>","category":"page"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"module Erosion\n\nusing DifferentialEquations\nusing CSV\nusing DataFrames\nusing Interpolations\n\ng(g‚Çò, I‚ÇÄ, I‚Çñ, k, w) = g‚Çò * tanh(I‚ÇÄ/I‚Çñ * exp(-w * k))\n\nstruct Parameters\n     I‚ÇÄ::Float64\n     I‚Çñ::Float64\n     k::Float64\n     g‚Çò::Float64\n     <<erosion-parameters>>\nend\n\ng(p::Parameters, w) = g(p.g‚Çò, p.I‚ÇÄ, p.I‚Çñ, p.k, w)\n\nfunction model(p::Parameters, s, t_end::Float64, h‚ÇÄ::Float64)\n     ‚àÇh(h::Float64, _, t::Float64) = let w = h - s(t)\n          w >= 0.0 ? -g(p, h - s(t)) : 0.0\n     end\n     ode = ODEProblem(‚àÇh, h‚ÇÄ, (0.0, t_end), Nothing)\n     solve(ode, Euler(), dt=10.0, reltol=1e-6, saveat=1000.0)\nend\n\nfunction sealevel_curve()\n     data = DataFrame(CSV.File(\"data/bs92-sealevel-curve.csv\"))\n     linear_interpolation(data.time, data.depth)\nend\n\nstruct Scenario\n     param::Parameters\n     sealevel\n     t_end::Float64\nend\n\nmodel(s::Scenario, h‚ÇÄ::Float64) = model(s.param, s.sealevel, s.t_end, h‚ÇÄ)\n\nSCENARIO_A = Scenario(\n     Parameters(2000.0, 250.0, 0.05, 0.005, 0.007),\n     sealevel_curve(),\n     80_000.0)\n\nend","category":"page"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"function erosion(p::Parameters)\n    p.dissolution_constant\nend","category":"page"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"<div class=\"noweb-label\">‚™°erosion-parameters‚™¢‚â£</div>","category":"page"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"dissolution_constant::Float64","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"title: CarboKitten subtitle: Sediment Transport ‚Äì-","category":"page"},{"location":"carbocat-transport/#Transport","page":"Sediment Transport","title":"Transport","text":"","category":"section"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"The sediment that is produced is distributed into lower lying neighbour cells that are not occupied by a producer. A user defined fraction of sediment from a producer is transported, first divided equally to lower neighbours, cascading to its neighbours by splitting in half and so on. The cascade stops when the sediment reaches a minimal threshold.","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"Thus, this step has two free parameters: the transported fraction of produced carbonate and the lower threshold.","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"Apparent from the illustration in B13 Figure 4, a 8-cell neighbourhood is used. Nothing is mentioned about the order in which the transport is computed. We may tag transported sediment with a bit flip and assign a new lythofacies to transported sediment.","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"<div class=\"noweb-label\">‚™°ck-types‚™¢‚â£</div>","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"struct Deposit{N}\n    amount::NTuple{N, Float64}\nend\n\nBase.zero(::Type{Deposit{N}}) where {N} =\n    Deposit{N}(ntuple(_ -> zero(Float64), N))","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013/Transport.jl</i></div>","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"module Transport\n\nusing ...BoundaryTrait\nusing ...Stencil\nusing Transducers\n\nstruct Product\n    species::Int\n    amount::Float64\nend\n\nBase.zero(::Type{Product}) = Product(0, 0.0)\n\nstruct Deposit{N}\n    amount::NTuple{N, Float64}\nend\n\nBase.zero(::Type{Deposit{N}}) where {N} =\n    Deposit{N}(ntuple(_ -> zero(Float64), N))\n\nfunction deposit(\n        ::Type{B},\n        production::Matrix{Product},\n        elevation::Matrix{Float64},\n        transported::Matrix{Deposit{N}},\n        lim::Float64,\n        idx::CartesianIndex,\n        p::Product\n    ) where {B <: Boundary{2}, N}\n\n    if p.amount <= lim\n        transported[idx][p.species] += p.amount\n        return\n    end\n\n    shape = size(production)\n    targets = CartesianIndices((-1:1,-1:1)) |>\n        Filter(Œîi -> Œîi!=CartesianIndex(0,0)) |>\n        Map(Œîi -> offset_index(B, shape, idx, Œîi)) |>\n        Filter(j -> !isnothing(j) &&\n                    elevation[j] >= elevation[idx] &&\n                    production[j].species == 0) |>\n        collect\n\n    if isempty(targets)\n        transported[idx][p.species] += p.amount\n        return\n    end\n    transported[idx][p.species] += p.amount / 2\n    for j in targets\n        q = Product(p.species, p.amount / (2 * length(targets)))\n        deposit(B, production, elevation, transported, lim, j, q)\n    end\nend\n\nfunction transport(\n        ::Type{B},\n        n_species::Int,\n        production::Matrix{Product},\n        elevation::Matrix{Float64},\n        fraction::Float64,\n        lim::Float64\n    ) where {B <: Boundary{2}}\n\n    shape = size(production)\n    result = zeros(Transported{n_species})\n\n    for i in CartesianIndices(shape)\n        production[i].amount <= lim && continue\n        p = copy(production[i])\n        p.amount *= fraction\n        production[i].amount -= p.amount\n        deposit(B, production, elevation, result, lim, i, p)\n    end\n\n    return result\nend\n\nend","category":"page"},{"location":"carbocat/#About","page":"Summary","title":"About","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"CarboCAT is primarily based on a very simple cellular automaton (CA). We may explore this CA as a first step in implementing the model in Julia.","category":"page"},{"location":"carbocat/#Overview","page":"Summary","title":"Overview","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"The CarboCAT model [B13: @Burgess2013] consists of several components, many of which are optional or contain optional levels of complexity.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Species habitation: an algorithm is in place to evolve the locality of a number of factory species.\nSediment production: each species will produce sediment according to some model.\nTransport: sediment may be transported from a production site to elsewhere due to gravity, waves or other types of mixing.\nErosion: sediment may erode depending on local circumstances or sediment type.\nCompactification: different types of sediment may respond to compression forces differently.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"These processes describe the intrinsic properties of the model. Any parameters that change these processes will be referred to as model parameters. Next to that, there are some extrinsic parameters that change the specific output of a model: the initial depth of the sea bed (also known as bathymetry) and variation in sea level (including subsidence). These we call input parameters.","category":"page"},{"location":"carbocat/#Carbonate-production","page":"Summary","title":"Carbonate production","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"By itself, a sediment production model is enough to model a cross-section of a carbonate platform [BS92: @Bosscher1992]. As a first step, we have reproduced some results of BS92. Using a reasonably simple approximation of a growth rate as","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"[partial_t h = - g_m tanh leftfracI_0I_k exp(-k * (h - s(t))right]{#eq:growth-rate-eqn}","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"where h is the depth of the sea floor, g_m is the maximum growth rate, I_0 the surface light intensity, I_k the saturating light intensity, k the extinction coefficient, and s the (extrinsic) sea-level. In one example given by BS92, we arrived at the following profile.","category":"page"},{"location":"carbocat/#Species-habitation","page":"Summary","title":"Species habitation","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"These species can be anything, just remember that they are the progenitor of some (limestone) facies type. In the original 2013 model, this stage is implemented by a celullar automaton (or CA). The CA has the nice property of giving pseudo-random output with at least some degree of coherence. There is no physical basis to the CA model, but neither is there very much data to test a physical model against.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"We have implemented the CA used in Burgess 2013. Using three species with identical 4-6-10-10 rules (survival between 4 to 10 neighbours, birth between 6-10 live neighbours).","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"(Image: )","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"An interesting question is under what rules is this CA stable (i.e. keeps evolving)?","category":"page"},{"location":"carbocat/#Combination","page":"Summary","title":"Combination","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"The minimal Carbocat model would consist of only species habitation and production.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":":::details","category":"page"},{"location":"carbocat/#Some-submodules","page":"Summary","title":"Some submodules","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013.jl</i></div>","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"module Burgess2013\n\ninclude(\"Burgess2013/Config.jl\")\ninclude(\"Burgess2013/CA.jl\")\ninclude(\"Burgess2013/Production.jl\")\ninclude(\"Burgess2013/Transport.jl\")\n\nusing .CA\nusing .Config\nusing .Production\n\nexport production_rate, run_ca, Facies, MODEL1\n\nend","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"noweb-label\">‚™°ck-types‚™¢‚â£</div>","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"export Product\n\nstruct Product\n    species::Int\n    amount::Float64\nend\n\nBase.zero(::Type{Product}) = Product(0, 0.0)","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013/Config.jl</i></div>","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"module Config\n\nusing Unitful\nexport Facies, MODEL1\n\n@kwdef struct Facies\n    viability_range::Tuple{Int, Int}\n    activation_range::Tuple{Int, Int}\n\n    maximum_growth_rate::typeof(1.0u\"m/Myr\")\n    extinction_coefficient::typeof(1.0u\"m^-1\")\n    saturation_intensity::typeof(1.0u\"W/m^2\")\nend\n\nMODEL1 = [\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 500u\"m/Myr\",\n           extinction_coefficient = 0.8u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\"),\n\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 400u\"m/Myr\",\n           extinction_coefficient = 0.1u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\"),\n\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 100u\"m/Myr\",\n           extinction_coefficient = 0.005u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\")\n]\n\nend","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":":::","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013/Production.jl</i></div>","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"module Production\n\nexport production_rate\n\nusing Unitful\nusing ..Config: Facies\n\n<<carbonate-production>>\n\nfunction production_rate(insolation, facies, water_depth)\n    g‚Çò = facies.maximum_growth_rate\n    I = insolation / facies.saturation_intensity\n    x = water_depth * facies.extinction_coefficient\n    return water_depth > 0.0u\"m\" ? g‚Çò * tanh(I * exp(-x)) : 0.0u\"m/Myr\"\nend\n\nend","category":"page"},{"location":"carbocat/#Crowding","page":"Summary","title":"Crowding","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"In crowded areas carbonate production rates are reduced. For cells where","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"n_min le n le n_opt","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"and","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"n_opt le n le n_max","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"(n_min and n_max for living cells are 4 and 10)","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"we have a linear increase and linear decrease of production rate (i.e. a triangle function).","category":"page"},{"location":"carbocat/#Subsidence","page":"Summary","title":"Subsidence","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Subsidence refers to gradual lowering or lifting of the underlying floor bed. This could be either sea level rise due to climate change, but also tectonic activity. Sea level also changes according to a given recipe with say three sinusoidals (e.g. Milankovich cycles). When a cell gets \"subaerial exposure\", i.e. the water level drops below the cell elevation (stupid jargon), accumulation stops and the cell becomes dormant. On reflooding, the cell resumes activity. From the text it is not entirely clear, but I think deactivated cells don't take part in the CA, so they count as dead neighbours.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"reference on accommodation, also links to a model called SedFlux.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"T + E = S + W","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Saying Tectonic subsidence plus Eustatic sea-level change equals Sedimentation plus change in Water depth.","category":"page"},{"location":"carbocat/#Steps","page":"Summary","title":"Steps","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Update waterdepth, given subsidence\nUpdate sea level elevation, given eustatics\nRun CA\nCompute thickness of carbonate production\nCompute sediment transport","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"We need to keep a state with the following components:","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"height map\nspecies\nglobal time, implying:\nsea level and subsidence","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Every cycle we may export a layer of sediment to archive.","category":"page"},{"location":"carbocat/#References","page":"Summary","title":"References","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"citation canonical\"><dl>\n</dl></div>","category":"page"},{"location":"bosscher-1992/#Carbonate-Production","page":"Bosscher and Schlager 1992","title":"Carbonate Production","text":"","category":"section"},{"location":"bosscher-1992/#reproducing-Bosscher-and-Schlager-1992","page":"Bosscher and Schlager 1992","title":"reproducing Bosscher & Schlager 1992","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The paper by [1] is an early computer model for simulating reef growth. This paper contains some of the essential ingredients that we find back in CarboCAT. Here we will try to reproduce their results.","category":"page"},{"location":"bosscher-1992/#Parameters","page":"Bosscher and Schlager 1992","title":"Parameters","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Maximum growth rate G_m. The maximum rate of reef growth is in the range of 10-15 rm mm yr^-1 (Macintyre etal., 1977; Adey, 1978; Davies, 1983).\nExtinction coefficient k. This is a measure of the extinction of photosynthetically active radiation (PAR), i.e. light with a wavelength of 400-700 nm.  The value of k for oceanic waters ranges from 004 to 016 rm m^-1 (Jerlov, 1976); reported values for reef waters also lie within this range (Brakel, 1979; Van den Hoek et al., 1975; Weinberg, 1976; Chalker, 1981; Porter, 1985).\nSurface light intensity I_0. The light intensity at the water surface at midday in the tropics lies in the range of 2000-2250 rm mu E m^-2s^-1.\nSaturating light intensity I_k. Light saturating intensities are in the range 50-450 rm mu E m^-2s^-1, depending on species and water depth (Chalker, 1981; Wyman et al., 1987). Photoadaptation of reef-building corals has not been taken into account. More generally, light does not become a limiting factor for coral growth until it reaches roughly 10% of its surface value (B. E. Chalker, in Done, 1983).","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"from BS92","category":"page"},{"location":"bosscher-1992/#Growth-Rate","page":"Bosscher and Schlager 1992","title":"Growth Rate","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The growth rate is","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"g(w) = g_m tanhleft(I_0 e^-kw over I_kright)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">‚™°carbonate-production‚™¢‚â£</div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"g(g‚Çò, I‚ÇÄ, I‚Çñ, k, w) = g‚Çò * tanh(I‚ÇÄ/I‚Çñ * exp(-w * k))","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">‚™°b92-model‚™¢‚â£</div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<<carbonate-production>>\n\nstruct Parameters\n     I‚ÇÄ::Float64\n     I‚Çñ::Float64\n     k::Float64\n     g‚Çò::Float64\nend\n\ng(p::Parameters, w) = g(p.g‚Çò, p.I‚ÇÄ, p.I‚Çñ, p.k, w)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"where w is the water depth in meters, g_m is the maximum growth rate in rm m rm My^-1, I_0 is surface light intensity, I_k is saturation light intensity, and k is the extinction coefficient. We have exponential decay of light intensity as we get to deeper water, and the carbonate factories respond to light intensity through a tanh (hyperbolic tangent function). This is by no means an exact relation, rather the tanh function interpolates smoothly between one and zero. We specify a maximum growth rate and a typical intensity at which the species is no longer productive.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The shape of tanh circ exp look like this:","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"(Image: Tangens hyperbolicus)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Notice that the numbers inside the exponential need to be unit-free, so does the output. The value of tanh circ exp at a depth of 0 is 07615dots. This does not make much sense, as I believe we should start at a value of 1 at the surface. By setting I_0  I_k to some value 1 this can be alleviated, but it changes the interpretation of the constants a little. The idea is that above a certain insolation, light is not the limiting factor to the rate of photosynthesis.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"To reproduce Figure 2 in B13, I had to change the values for g_m to 500, 250, and 125 respectively, the other values from Table 2 remained the same. I guess this was done for illustration purposes.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"(Image: Production curves)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/plot-tanh.gnuplot</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"set term svg size 700, 300 font \"sans serif, 14\" linewidth 1.5\nset xrange [-5:10]\nset yrange [-0.1:1.1]\nset grid\nset key outside\nset xlabel \"x\"\nset ylabel \"y\"\nplot tanh(exp(-x)) lc rgb 'black', tanh(exp(4)*exp(-x)), tanh(exp(-0.5*x))","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/burgess2013-fig2.gnuplot</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"set term svg size 500, 600 font \"sans serif,14\" linewidth 1.5\nset trange [0:100]\nset yrange [100:0]\nset xrange [-20:520]\nset parametric\nset key right bottom\nset grid\nset ylabel \"Water depth (m)\"\nset xlabel \"Production rates\"\nplot 500*tanh(6.7 * exp(-0.8 * t)), t title 'Carbonate factory 1', \\\n     250*tanh(6.7 * exp(-0.1 * t)), t title 'Carbonate factory 2', \\\n     125*tanh(6.7 * exp(-0.005 * t)), t title 'Carbonate factory 3'","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"</details>","category":"page"},{"location":"bosscher-1992/#Depth-Evolution","page":"Bosscher and Schlager 1992","title":"Depth Evolution","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The use of water depth in both BS92 and B13 can be a bit confusing. Plots are shown up-side-down and little is done to disambiguate depth with sea level rising or lowering, or sediment accreting. Growth in deposition should give shallower sea bed. BS92 write w = (h_0 + h(t)) - (s_0 + s(t)). Actually s_0 is best set to 0, or simply included into s(t) and h_0 can be replaced with setting h(t=0) = h_0. Then, as we have the growth rate as a function of water depth g(w), we can say","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"[partial_t h = -g_m rm tanhleftfracI_0I_k exp(-k (h - s(t)))right]{#eq:growth-eqn}","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">‚™°b92-model‚™¢‚äû</div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"function model(p::Parameters, s, t_end::Float64, h‚ÇÄ::Float64)\n     ‚àÇh(h::Float64, _, t::Float64) = let w = h - s(t)\n          w >= 0.0 ? -g(p, h - s(t)) : 0.0\n     end\n     ode = ODEProblem(‚àÇh, h‚ÇÄ, (0.0, t_end), Nothing)\n     solve(ode, Euler(), dt=10.0, reltol=1e-6, saveat=1000.0)\nend","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"It seems Eq. 5 in BS92 (the most important equation in the paper mind you!) is missing both a minus sign and a set of parentheses. Also, we should remark that at negative depth (subareal exposure) we should halt all growth.","category":"page"},{"location":"bosscher-1992/#Crosssection","page":"Bosscher and Schlager 1992","title":"Crosssection","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The most impressive result in BS92 is the last figure. They show an input curve for s(t) but give no functional description. The curve starts with a linear drop from 0 to 120m depth over a time of 20000 years, then slowly rises with s(t) = a +  bt + A sin(2pi t  P), with a period P = sim 15-20 rm kyr, amplitude A = sim 40 rm m. It might be easiest to take a screenshot of the PDF and convert the graph into a table.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<details><summary>Extracting Sealevel Curve from an image</summary>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/BS92/fig8-sealevel.jl</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"#| creates: data/bs92-sealevel-curve.csv\n#| requires: data/bs92-sealevel-input.png\n\nmodule Script\n    using Images\n    using DataFrames\n    using CSV\n\n    function main()\n        img = load(\"data/bs92-sealevel-input.png\")\n        img_gray = Gray.(img)\n        signal = 1.0 .- channelview(img_gray)\n        signal ./= sum(signal; dims=[1])\n        (n_y, n_x) = size(signal)\n        y = sum(signal .* (1:n_y); dims=[1]) / n_y * 200.0\n        df = DataFrame(\n            time = LinRange(0.0, 80_000.0, n_x),\n            depth = y[1, :])\n        CSV.write(\"data/bs92-sealevel-curve.csv\", df)\n    end\nend\n\nScript.main()","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"</details>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Using DifferentialEquations.jl we can integrate Equation @eq:growth-eqn. Interestingly, the only integrator that gave me noise free results is Euler. This may be due to the sudden shut-down of production at w = 0.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/BS92/BS92.jl</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"module BS92\n\nusing DifferentialEquations\nusing CSV\nusing DataFrames\nusing Interpolations\n\n<<b92-model>>\n\nfunction sealevel_curve()\n     data = DataFrame(CSV.File(\"data/bs92-sealevel-curve.csv\"))\n     linear_interpolation(data.time, data.depth)\nend\n\nstruct Scenario\n     param::Parameters\n     sealevel\n     t_end::Float64\nend\n\nmodel(s::Scenario, h‚ÇÄ::Float64) = model(s.param, s.sealevel, s.t_end, h‚ÇÄ)\n\nSCENARIO_A = Scenario(\n     Parameters(2000.0, 250.0, 0.05, 0.005),\n     sealevel_curve(),\n     80_000.0)\n\nend","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Finally, we can try to reproduce figure 8 in BS92.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"(Image: stratigraphy following fig. 8 in BS92)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Note the simplicity of this result: there is no dependency on space, only on the initial depth h_0.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/BS92/fig8.jl</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"#| creates: docs/src/fig/bs92-fig8.svg\n#| requires: data/bs92-sealevel-curve.csv examples/BS92/BS92.jl\n#| collect: figures\n\nmodule Script\n     include(\"BS92.jl\")\n     using CairoMakie\n\n     function main()\n          h0 = LinRange(0, 200, 101)\n          result = hcat([BS92.model(BS92.SCENARIO_A, h).u for h in h0]...)\n          t = LinRange(0, 80_000, 81)\n\n          fig = Figure(resolution=(600,900))\n          ax = Axis(fig[1,1], xlabel=\"initial depth (m)\", ylabel=\"depth (m)\", yreversed=true)\n          for l in eachrow(result)\n               lines!(ax, h0, vec(l); color=:steelblue4, linewidth=0.5)\n          end\n          ax = Axis(fig[2,1], xlabel=\"time (years)\", ylabel=\"depth (m)\", yreversed=true)\n          lines!(ax, t, BS92.SCENARIO_A.sealevel(t); color=:steelblue4)\n\n          save(\"docs/src/fig/bs92-fig8.svg\", fig)\n     end\nend\n\nScript.main()","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"</details>","category":"page"},{"location":"utility/#Utility-functions","page":"Utility","title":"Utility functions","text":"","category":"section"},{"location":"utility/#Select-Iterator","page":"Utility","title":"Select Iterator","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"In many cases our model is updating some state as an iterator. I want to be able to select arbitrary slices from that iterator. The Select object contains the main iterable and a selection iterable that should yield integers. When iterated upon, we repeatedly use Iterators.dropwhile to get to the next index.","category":"page"},{"location":"utility/","page":"Utility","title":"Utility","text":"<div class=\"noweb-label\">file:<i>src/Utility.jl</i></div>","category":"page"},{"location":"utility/","page":"Utility","title":"Utility","text":"module Utility\n\nexport select, in_units_of\nusing Unitful\n\nstruct Select\n    iter\n    selection\nend\n\nfunction select(it, sel)\n    Select(enumerate(it), sel)\nend\n\nfunction Base.iterate(s::Select)\n    x = iterate(s.selection)\n    if x !== nothing\n        (idx, selstate) = x\n        ((_, value), rest) = Iterators.peel(Iterators.dropwhile(((i, y),) -> i != idx, s.iter))\n        return (value, (selstate, rest))\n    else\n        return nothing\n    end\nend\n\nfunction Base.iterate(s::Select, state)\n    (selstate, rest) = state\n    x = iterate(s.selection, selstate)\n    if x !== nothing\n        (idx, selstate) = x\n        ((_, value), rest) = Iterators.peel(Iterators.dropwhile(((i, y),) -> i != idx, s.iter))\n        return (value, (selstate, rest))\n    else\n        return nothing\n    end\nend\n\n<<utility>>\n\nend","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"title: Species Habitation subtitle: a cellular automaton ‚Äì-","category":"page"},{"location":"carbocat-ca/#Cellular-Automaton","page":"Cellular Automaton","title":"Cellular Automaton","text":"","category":"section"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"The paper talks about cycling the order of preference for occupying an empty cell at each iteration. This means that the rules change slightly every iteration.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">‚™°cycle-permutation‚™¢‚â£</div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"cycle_permutation(n_species::Int) =\n    (circshift(1:n_species, x) for x in Iterators.countfrom(0))","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"The stencil function has an args... variadic arguments that are forwarded to the given rule. This means we can create a rules function that we pass the preference order as a second argument.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">‚™°burgess2013-rules‚™¢‚â£</div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"function rules(facies::Vector{Facies})\n    function (neighbourhood::Matrix{Int}, order::Vector{Int})\n        cell_facies = neighbourhood[3, 3]\n        neighbour_count(f) = sum(neighbourhood .== f)\n        if cell_facies == 0\n            for f in order\n                n = neighbour_count(f)\n                (a, b) = facies[f].activation_range\n                if a <= n && n <= b\n                    return f\n                end\n            end\n            0\n        else\n            n = neighbour_count(cell_facies) - 1\n            (a, b) = facies[cell_facies].viability_range\n            (a <= n && n <= b ? cell_facies : 0)\n        end\n    end    \nend\n\nfunction run_ca(::Type{B}, facies::Vector{Facies}, init::Matrix{Int}, n_species::Int) where {B <: Boundary{2}}\n    r = rules(facies)\n    Channel{Matrix{Int}}() do ch\n        target = Matrix{Int}(undef, size(init))\n        put!(ch, init)\n        stencil_op = stencil(Int, B, (5, 5), r)\n        for perm in cycle_permutation(n_species)\n            stencil_op(init, target, perm)\n            init, target = target, init\n            put!(ch, init)\n        end\n    end\nend","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"This function is not yet adaptible to the given rule set. Such a modification is not so hard to make. ","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"The paper talks about a 50x50 grid initialized with uniform random values.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013/CA.jl</i></div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"module CA\n\nusing ...BoundaryTrait\nusing ...Stencil\nusing ..Config: Facies\n\nexport run_ca\n\n<<cycle-permutation>>\n<<burgess2013-rules>>\n\nend","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"First, let us reproduce Figure 3 in Burgess 2013.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"(Image: First 8 generations)","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"By eye comparison seems to indicate that this CA is working the same. I'm curious to the behaviour after more iterations. Let's try 10, 100, 10000 and so on.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"(Image: Assymptotic behaviour)","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"The little qualitative change between 100 and 1000 iterations would indicate that this CA remains \"interesting\" for a long time.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"On my laptop I can run about 150 iterations per second with current code. When using periodic boundaries, I get to 1500 iterations per second, which is peculiar. A lot can still be optimized.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">file:<i>examples/ca/burgess-2013.jl</i></div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"module Script\n    using .Iterators: flatten\n    using CarboKitten\n    using CarboKitten.Burgess2013\n    using CarboKitten.Stencil: Reflected\n    using CarboKitten.Utility\n    using GLMakie\n\n    function main()\n        init = rand(0:3, 50, 50)\n        ca = run_ca(Reflected{2}, MODEL1, init, 3)\n\n        fig = Figure(resolution=(1000, 500))\n        axis_indices = flatten(eachrow(CartesianIndices((2, 4))))\n        for (i, st) in zip(axis_indices, ca)\n            ax = Axis(fig[Tuple(i)...], aspect=AxisAspect(1))\n            heatmap!(ax, st)\n        end\n        save(\"docs/src/fig/b13-fig3.png\", fig)\n    end\nend\n\nScript.main()","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">file:<i>examples/ca/long-term.jl</i></div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"module Script\n    using CarboKitten\n    using CarboKitten.Burgess2013\n    using CarboKitten.Stencil\n    using CarboKitten.Utility\n    using GLMakie\n\n    function main()\n        init = rand(0:3, 50, 50)\n        result = select(run_ca(Periodic{2}, MODEL1, init, 3), [10, 100, 10000])\n\n        fig = Figure(resolution=(1000, 333))\n        for (i, st) in enumerate(result)\n            ax = Axis(fig[1, i], aspect=AxisAspect(1))\n            heatmap!(ax, st)\n        end\n        save(\"docs/src/fig/b13-long-term.png\", fig)\n    end\nend\n\nScript.main()","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"</details>","category":"page"},{"location":"carbocat-ca/#How-to-run","page":"Cellular Automaton","title":"How to run","text":"","category":"section"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"We start with randomized initial conditions on a 50x50 grid.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"using CarboKitten.Stencil: Reflected\nusing CarboKitten.Burgess2013\ninit = rand(0:3, 50, 50)\nresult = Iterators.take(run_ca(Reflected{2}, MODEL1, init, 3), 8)","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"Then we run the cellular automaton for, in this case eight generations. The CA.run function returns an iterator of 50x50 maps. That means that in principle we can extract an infinity of iterations, but in this cane we only take eight.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"result = Iterators.take(CA.run(Reflected{2}, init, 3), 8)","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"In Julia we may plot those as follows","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"using Plots\n# plotly()  # sets back-end; plotly gives me the best results\nplot((heatmap(r, colorbar=:none) for r in result)..., layout=(2, 4))","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"What this says is: create a heatmap for each of our eight results, then expand those into a function call to plot (as in plot(hm1, hm2, ..., hm8, layout=(2, 4))).","category":"page"},{"location":"carbocat-ca/#Parameter-scan","page":"Cellular Automaton","title":"Parameter scan","text":"","category":"section"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">file:<i>examples/ca/parameter-scan.jl</i></div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"module Script\n\nusing CarboKitten\nusing CarboKitten.Burgess2013\nusing CarboKitten.Stencil\nusing CarboKitten.Utility\nusing GLMakie\nusing .Iterators: peel, drop\n\nfunction main()\n    fig = Figure(resolution=(2000, 2000))\n    for i in 4:12\n        for j in (i+1):12\n            print(\".\")\n            gl = fig[i, j] = GridLayout()\n            for k in i:j\n                # for l in k:j\n                let l = j\n                    init = rand(0:3, 50, 50)\n                    facies = [\n                        Facies((i, j), (k, l), 0, 0, 0),\n                        Facies((i, j), (k, l), 0, 0, 0),\n                        Facies((i, j), (k, l), 0, 0, 0),\n                    ]\n                    (result, _) = peel(drop(run_ca(Periodic{2}, facies, init, 3), 10))\n\n                    ax = Axis(gl[k-i, l-k], aspect=AxisAspect(1),\n                              xticksvisible=false, xticklabelsvisible=false,\n                              yticksvisible=false, yticklabelsvisible=false)\n                    heatmap!(ax, result)\n                end\n            end\n        end\n    end\n    save(\"docs/src/fig/parameter-scan.png\", fig)\nend\n\nend  # module Script\n\nScript.main()","category":"page"},{"location":"boxes/#Generic-Parameters","page":"Boxes","title":"Generic Parameters","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">file:<i>src/Config.jl</i></div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"module Config\n\nexport AbstractBox, Box\n\nusing ..BoundaryTrait\nusing ..Vectors\n\nusing Unitful\nusing Unitful.DefaultSymbols\n\n<<config-types>>\n\nend","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Physical parameters of CarboKitten all should have units, see our refresher on Unitful.jl.","category":"page"},{"location":"boxes/#Box-topology","page":"Boxes","title":"Box topology","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"CarboKitten has a 3-dimensional state space, where two dimensions represent cartesian topographic coordinates, and the third dimension is a track record of sedimentation. The cartesian topographic coordinates are always on a regular grid, but depending on the scenario you may choose different map topologies.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"periodic boundaries To study sedimentation in a small isolated patch, periodic boundaries seem sufficient. The field is assumed to be infinite in all directions.\nVon Neumann boundaries In the case of an island it is nicer to have boundaries with constant derivatives. Produced sediment that flows out of the box is lost to the seas.\ncoastal shelf boundaries Supposing we simulate a narrow cross section of a carbonate shelf, we'll have one periodic boundary (in y-direction) and Von Neumann boundaries in the x-direction.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"We parametrize these boundaries as type-level constants in Julia. This way we can use the multiple dispatch mechanism in Julia to obtain specialized implementations for each boundary case, selected at compile time, resulting in efficient run-times.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°boundary-types‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"abstract type Boundary{dim} end\nstruct Reflected{dim} <: Boundary{dim} end\nstruct Periodic{dim} <: Boundary{dim} end\nstruct Constant{dim,value} <: Boundary{dim} end\nstruct Shelf <: Boundary{2} end","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"The Boundary type is part of the generic Box dimension specification.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°config-types‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"abstract type AbstractBox{BT} end\n\nstruct Box{BT} <: AbstractBox{BT}\n    grid_size::NTuple{2,Int}\n    phys_scale::typeof(1.0m)\n    phys_size::Vec2\n\n    function Box{BT}(;grid_size::NTuple{2, Int}, phys_scale::Quantity{Float64, ùêã, U}) where {BT <: Boundary{2}, U}\n        new{BT}(grid_size, phys_scale, phys_size(grid_size, phys_scale))\n    end\nend\n\nphys_size(grid_size, phys_scale) = (\n    x = grid_size[1] * (phys_scale / m |> NoUnits),\n    y = grid_size[2] * (phys_scale / m |> NoUnits))","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Now we can specify the box parameters as follows:","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">file:<i>test/ConfigSpec.jl</i></div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"@testset \"Config\" begin\n    using CarboKitten.BoundaryTrait\n    using CarboKitten.Config: Box\n    using CarboKitten.Vectors\n\n    box = Box{Shelf}(\n        grid_size = (100, 50),\n        phys_scale = 1.0u\"km\")\n    @test box.phys_size == (x=100000.0, y=50000.0)\nend","category":"page"},{"location":"boxes/#Time-properties","page":"Boxes","title":"Time properties","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Time stepping is specified in TimeProperties. We'll have time_steps number of time steps, each of physical time Œît. However, only one in write_interval steps is written to disk.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°config-types‚™¢‚äû</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"abstract type AbstractTimeProperties end\n\n@kwdef struct TimeProperties <: AbstractTimeProperties\n    Œît::typeof(1.0u\"yr\")\n    steps::Int\n    write_interval::Int\nend","category":"page"},{"location":"boxes/#Vectors","page":"Boxes","title":"Vectors","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"To trace the position of particles we define a NamedTuple with x and y members and define common vector operations on those.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">file:<i>src/Vectors.jl</i></div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"module Vectors\n\nexport Vec2\n\nVec2 = @NamedTuple{x::Float64, y::Float64}\nBase.:+(a::Vec2, b::Vec2) = (x=a.x+b.x, y=a.y+b.y)\nBase.abs2(a::Vec2) = a.x^2 + a.y^2\nBase.abs(a::Vec2) = ‚àö(abs2(a))\nBase.:*(a::Vec2, b::Float64) = (x=a.x*b, y=a.y*b)\nBase.:/(a::Vec2, b::Float64) = (x=a.x/b, y=a.y/b)\nBase.:*(a::Float64, b::Vec2) = b*a\nBase.:-(a::Vec2, b::Vec2) = (x=a.x-b.x, y=a.y-b.y)\nBase.:-(a::Vec2) = (x=-a.x, y=-a.y)\nBase.zero(::Type{Vec2}) = (x=0.0, y=0.0)\n\nend","category":"page"},{"location":"boxes/#Offset-indexing","page":"Boxes","title":"Offset indexing","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Now we can use these traits to define three methods for indexing on an offset from some index that is assumed to be within bounds.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°spec‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"@testset \"offset_value\" begin\n    @test CartesianIndex(1, 1) == offset_index(Reflected{2}, (3, 3), CartesianIndex(1, 1), CartesianIndex(0, 0))\nend","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°offset-indexing‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"function offset_index(::Type{BT}, shape::NTuple{dim,Int}, i::CartesianIndex, Œîi::CartesianIndex) where {dim, BT <: Boundary{dim}}\n    canonical(BT, shape, i + Œîi)\nend\n\nfunction offset_value(BT::Type{B}, z::AbstractArray, i::CartesianIndex, Œîi::CartesianIndex) where {dim,B<:Boundary{dim}}\n    z[offset_index(BT, size(z), i, Œîi)]\nend\n\nfunction offset_value(::Type{Constant{dim,value}}, z::AbstractArray, i::CartesianIndex, Œîi::CartesianIndex) where {dim,value}\n    j = i + Œîi\n    (checkbounds(Bool, z, j) ? z[j] : value)\nend","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">file:<i>src/BoundaryTrait.jl</i></div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"module BoundaryTrait\n\nexport Boundary, Reflected, Periodic, Constant, Shelf, offset_index, offset_value, canonical\n\n<<boundary-types>>\n<<offset-indexing>>\n<<canonical-coordinates>>\n\nend","category":"page"},{"location":"boxes/#Canonical-coordinates","page":"Boxes","title":"Canonical coordinates","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"For both Periodic and Reflected boundaries it is also possible to write a function that makes any coordinate within bounds. This uses the fact that reflected boundaries are also periodic for a box twice the size.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°canonical-coordinates‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"function canonical(::Type{Periodic{dim}}, shape::NTuple{dim,Int}, i::CartesianIndex) where {dim}\n    CartesianIndex(mod1.(Tuple(i), shape)...)\nend\n\nfunction canonical(::Type{Reflected{dim}}, shape::NTuple{dim,Int}, i::CartesianIndex) where {dim}\n    modflip(a, l) = let b = mod1(a, 2l)\n        b > l ? 2l - b + 1 : b\n    end\n    CartesianIndex(modflip.(Tuple(i), shape)...) \nend\n\nfunction canonical(::Type{Constant{dim, value}}, shape::NTuple{dim,Int}, i::CartesianIndex) where {dim, value}\n    all(checkindex.(Bool, range.(1, shape), Tuple(i))) ? i : nothing\nend","category":"page"},{"location":"boxes/#Shelf-boundary","page":"Boxes","title":"Shelf boundary","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"The Shelf boundary type is specially designed for the simulation of a transect perpendicular to the coast direction. We are periodic in the y-direction and have a Neumannesque constant boundary at the edges of the simulation area.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°offset-indexing‚™¢‚äû</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"function canonical(::Type{Shelf}, shape::NTuple{2, Int}, i::CartesianIndex)\n    if i[1] < 1 || i[1] > shape[1]\n        return nothing\n    end\n    return CartesianIndex(i[1], mod1(i[2], shape[2]))\nend\n\nfunction offset_value(::Type{Shelf}, z::AbstractArray, i::CartesianIndex, Œîi::CartesianIndex)\n    j = i + Œîi\n    shape = size(z)\n    if j[1] < 1\n        return z[1, mod1(j[2], shape[2])]\n    elseif j[1] > shape[1]\n        return z[shape[1], mod1(j[2], shape[2])]\n    else\n        return z[j[1], mod1(j[2], shape[2])]\n    end\nend","category":"page"},{"location":"boxes/#Boxes","page":"Boxes","title":"Boxes","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"We need to define how particles move past boundaries. Similar to the grid based offset_index method, we define the offset method for a Vec2.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°vector-offset‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Base.in(a::Vec2, box::Box) =\n    a.x >= 0.0 && a.x < box.phys_size.x && a.y >= 0.0 && a.y < box.phys_size.y\n\nfunction offset(box::AbstractBox{Reflected{2}}, a::Vec2, Œîa::Vec2)\n    clip(i, a, b) = (i < a ? a + a - i : (i > b ? b + b - i : i))\n    (x=clip(a.x+Œîa.x, 0.0, box.phys_size.x)\n    ,y=clip(a.y+Œîa.y, 0.0, box.phys_size.y))\nend\n\nfunction offset(box::AbstractBox{Periodic{2}}, a::Vec2, Œîa::Vec2)\n    (x=mod(a.x+Œîa.x, box.phys_size.x)\n    ,y=mod(a.y+Œîa.y, box.phys_size.y))\nend\n\nfunction offset(box::AbstractBox{Constant{2,Value}}, a::Vec2, Œîa::Vec2) where Value\n    b = a + Œîa\n    if b ‚àâ box\n        nothing\n    else\n        b\n    end\nend\n\nfunction offset(box::AbstractBox{Shelf}, a::Vec2, Œîa::Vec2)\n    b = a + Œîa\n    if b.x < 0.0 || b.x >= box.phys_size.x\n        nothing\n    else\n        (x=b.x, y=mod(b.y, box.phys_size.y))\n    end\nend","category":"page"},{"location":"ca-with-production/#Combining-CA-with-production","page":"Model with CA and Production","title":"Combining CA with production","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"This model combines BS92 production with the B13 cellular automaton.","category":"page"},{"location":"ca-with-production/#Complete-example","page":"Model with CA and Production","title":"Complete example","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"This example is running for 10000 steps to 1Myr on a 100 times 50 grid, starting with a sloped height down to 50m. The sea_level, and initial_depth arguments are functions. The phys_scale argument translate pixels on the grid into physical metres. The write_interval indicates to write output every 10 iterations, summing the production over that range. You may copy paste the following code into your own script or notebook, and play around with input values.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/production-only/caps-osc.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: data/caps-osc.h5\n#| requires: src/CaProd.jl\n\nmodule Script\nusing CarboKitten.BoundaryTrait: Shelf\nusing CarboKitten.Config: Box, TimeProperties\nusing CarboKitten.Burgess2013.Config: MODEL1\nusing CarboKitten.CaProd\nusing Unitful\n\nconst PERIOD = 200.0u\"kyr\"\nconst AMPLITUDE = 4.0u\"m\"\n\nconst DEFAULT_INPUT = CaProd.Input(\n  box = Box{Shelf}(\n    grid_size = (100, 50),\n    phys_scale = 0.15u\"km\"\n    # equivalent:\n    # phys_scale = 150\"m\"\n  ),\n  time = TimeProperties(\n    Œît = 0.0001u\"Myr\",\n    # equivalent: \n    # Œît = 1u\"kyr\",\n    steps = 10000,\n    write_interval = 10\n  ),\n  sea_level = t -> AMPLITUDE * sin(2œÄ * t / PERIOD), \n  subsidence_rate=50.0u\"m/Myr\",\n  initial_depth=x -> x / 300.0,\n  facies=MODEL1,\n  insolation=400.0u\"W/m^2\"\n)\nend\n\nScript.CaProd.main(Script.DEFAULT_INPUT, \"data/caps-osc.h5\")","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"This writes output to an HDF5 file that you may use for further analysis and visualization.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/plot-caps-osc.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: docs/src/fig/b13-capsosc-crosssection.png\n#| requires: data/caps-osc.h5 ext/VisualizationExt.jl\n#| collect: figures\n\nmodule Script\n    using CairoMakie\n    using GeometryBasics\n    using CarboKitten.Visualization\n\n    function main()\n        f = Figure()\n        plot_crosssection(f[1,1], \"data/caps-osc.h5\")\n     save(\"docs/src/fig/b13-capsosc-crosssection.png\", f)\n    end\nend\n\nScript.main()","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"(Image: Stratigraphy, production and subsidence under oscillating sea level.)","category":"page"},{"location":"ca-with-production/#Input","page":"Model with CA and Production","title":"Input","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"initial depth (function of space)\nsea-level curve (function of time)\nsubsidence (function of time)\nfacies types","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"These should all behave as a functions, but could also be some interpolated data. The signs of these quantities should be such that the following equation holds:","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"T + E = S + W","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"Saying Tectonic subsidence plus Eustatic sea-level change equals Sedimentation plus change in Water depth.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-input‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"@kwdef struct Input\n    box :: Box\n    time :: TimeProperties\n\n    sea_level       # Myr -> m\n    subsidence_rate::typeof(1.0u\"m/Myr\")\n    initial_depth   # m -> m\n\n    facies::Vector{Facies}\n    insolation::typeof(1.0u\"W/m^2\")\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"In the case write_interval is not one, we will sum production rates over several iterations of the model before writing to output. In that case sediment production per written frame is no longer limited to a single facies.","category":"page"},{"location":"ca-with-production/#Output","page":"Model with CA and Production","title":"Output","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"Each iteration of the model, we produce a Frame.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-frame‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"struct Frame\n    production::Array{typeof(1.0u\"m/Myr\"),3}\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The frame is used to update a state S. The frame should be considered a delta for the state. So, we can reproduce the height at each step from the frames.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-state‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"mutable struct State\n    time::typeof(1.0u\"Myr\")\n    height::Array{typeof(1.0u\"m\"),2}\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The output is principally all frames produced in the simulation, in a 4-dimensional array. The first two dimensions are x, y positions on the grid, the third is the facies and the fourth dimension is time. We store the output in HDF5, having an input group where we store the input data, and a sediment dataset containing the aforementioned 4-dimensional output data. Note that these are production rates, so to reconstruct the sea floor depth at any time, you need to multiply by Delta t * n_w, where n_w is the write_interval and take a cumulative sum.","category":"page"},{"location":"ca-with-production/#Logic","page":"Model with CA and Production","title":"Logic","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"From a dynamical modeling point of view, CarboCAT operates analogous to a forward Euler integration scheme, where some components are actually a discrete model. This means we have one function that generates a Frame from a State, called the propagator P (this is our own nomenclature),","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"P_i S to Delta","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The suffix i here is used to indicate that the propagator depends on the input. We'll have a second function U that updates the state with the given frame,","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"U (S Delta) to S","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"In practice however, the update function changes the state in-place.","category":"page"},{"location":"ca-with-production/#Init","page":"Model with CA and Production","title":"Init","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"We fill the height map with the initial depth function. It is assumed that the height only depends on the second index.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-model‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"function initial_state(input)  # -> State\n    height = zeros(Float64, input.box.grid_size...) * u\"m\"\n    for i in CartesianIndices(height)\n        height[i] = input.initial_depth(i[1] * input.box.phys_scale)\n    end\n    return State(0.0u\"Myr\", height)\nend","category":"page"},{"location":"ca-with-production/#Propagator","page":"Model with CA and Production","title":"Propagator","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The propagator computes the production rates (and also erosion) given the state of the model.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-model‚™¢‚äû</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"function propagator(input)\n    <<ca-prod-init-propagator>>\n    function (s)  # -> Frame\n        <<ca-prod-propagate>>\n    end\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The propagator keeps the cellular automaton as an internal state, but this may also be considered to be an input function. This may change when you'd want to influence the CA with environmental factors. Then the CA becomes an integral component of the dynamical model. The CA would then have to keep state in the State variable. We burn the first 20 iterations of the CA to start with a realistic pattern.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-init-propagator‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"n_facies = length(input.facies)\nca_init = rand(0:n_facies, input.box.grid_size...)\nca = drop(run_ca(Periodic{2}, input.facies, ca_init, 3), 20)\n\nfunction water_depth(s)\n    s.height .- input.sea_level(s.time)\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"Now, to generate a production from a given state, we advance the CA by one step and compute the production accordingly.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-propagate‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"result = zeros(typeof(0.0u\"m/Myr\"), input.box.grid_size..., n_facies)\nfacies_map, ca = peel(ca)\nw = water_depth(s)\nfor idx in CartesianIndices(facies_map)\n    f = facies_map[idx]\n    if f == 0\n        continue\n    end\n    result[Tuple(idx)..., f] = production_rate(input.insolation, input.facies[f], w[idx])\nend\nreturn Frame(result)","category":"page"},{"location":"ca-with-production/#Updater","page":"Model with CA and Production","title":"Updater","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"Every iteration we update the height variable with the subsidence rate, and add sediments to the height.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-model‚™¢‚äû</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"function updater(input::Input)\n    n_facies = length(input.facies)\n    function (s::State, Œî::Frame)\n        s.height .-= sum(Œî.production; dims=3) .* input.time.Œît\n        s.height .+= input.subsidence_rate * input.time.Œît\n        s.time += input.time.Œît\n    end\nend","category":"page"},{"location":"ca-with-production/#Loop","page":"Model with CA and Production","title":"Loop","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-model‚™¢‚äû</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"function run_model(input::Input)\n    Channel{Frame}() do ch\n        s = initial_state(input)\n        p = propagator(input)\n        u = updater(input)\n\n        while true\n            Œî = p(s)\n            put!(ch, Œî)\n            u(s, Œî)\n        end\n    end\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>src/CaProd.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"module CaProd\n\nusing CarboKitten\nusing ..Utility\nusing ..Config: Box, TimeProperties\nusing ..BoundaryTrait: Periodic\nusing ..Utility\n# using CarboKitten.BS92: sealevel_curve\nusing ..Stencil\nusing ..Burgess2013\n\nusing HDF5\nusing Unitful\nusing .Iterators: drop, peel, partition, map, take\n\n<<ca-prod-input>>\n<<ca-prod-frame>>\n<<ca-prod-state>>\n<<ca-prod-model>>\n\nfunction stack_frames(fs::Vector{Frame})  # -> Frame\n    Frame(sum(f.production for f in fs))\nend\n\nfunction main(input::Input, output::String)\n    y_axis = (0:(input.box.grid_size[2]-1)) .* input.box.phys_scale\n    x_axis = (0:(input.box.grid_size[1]-1)) .* input.box.phys_scale\n    initial_height = input.initial_depth.(x_axis)\n    n_writes = input.time.steps √∑ input.time.write_interval\n\n    h5open(output, \"w\") do fid\n        gid = create_group(fid, \"input\")\n        gid[\"x\"] = collect(x_axis) |> in_units_of(u\"m\")\n        gid[\"y\"] = collect(y_axis) |> in_units_of(u\"m\")\n        gid[\"height\"] = collect(initial_height) |> in_units_of(u\"m\")\n        gid[\"t\"] = collect((0:(n_writes-1)) .* (input.time.Œît * input.time.write_interval)) |> in_units_of(u\"Myr\")\n        attr = attributes(gid)\n        attr[\"delta_t\"] = input.time.Œît |> in_units_of(u\"Myr\")\n        attr[\"write_interval\"] = input.time.write_interval\n        attr[\"time_steps\"] = input.time.steps\n        attr[\"subsidence_rate\"] = input.subsidence_rate |> in_units_of(u\"m/Myr\")\n        attr[\"n_facies\"] = length(input.facies)\n\n        n_facies = length(input.facies)\n        ds = create_dataset(fid, \"sediment\", datatype(Float64),\n            dataspace(input.box.grid_size..., n_facies, input.time.steps),\n            chunk=(input.box.grid_size..., n_facies, 1))\n\n        results = map(stack_frames, partition(run_model(input), input.time.write_interval))\n        for (step, frame) in enumerate(take(results, n_writes))\n            ds[:, :, :, step] = frame.production |> in_units_of(u\"m/Myr\")\n        end\n    end\nend\n\nend # CaProd","category":"page"},{"location":"ca-with-production/#Case-1","page":"Model with CA and Production","title":"Case 1","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The first case uses the same settings as Burgess 2013: an initial depth of 2m, subsidence rate of 50 m/Myr and constant sea level.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/production-only/ca-uniform.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: data/ca-prod.h5\n#| requires: src/CaProd.jl\n\nmodule Script\nusing CarboKitten.CaProd\nusing CarboKitten.BoundaryTrait\nusing CarboKitten.Config: Box, TimeProperties\nusing CarboKitten.Burgess2013.Config: MODEL1\nusing Unitful\n\nconst DEFAULT_INPUT = CaProd.Input(\n  box = Box{Periodic{2}}(\n    grid_size = (50, 50),\n    phys_scale = 1.0u\"m\"\n  ),\n  time = TimeProperties(\n    Œît = 0.001u\"Myr\",\n    steps = 1000,\n    write_interval = 1\n  ),\n  sea_level=_ -> 0.0u\"m\",\n  subsidence_rate=50.0u\"m/Myr\",\n  initial_depth=_ -> 2.0u\"m\",\n  facies=MODEL1,\n  insolation=2000.0u\"W/m^2\"\n)\nend\n\nCaProd.main(Script.DEFAULT_INPUT, \"data/ca-prod.h5\")","category":"page"},{"location":"ca-with-production/#Case-2","page":"Model with CA and Production","title":"Case 2","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"For the second case, we start with a slope.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/production-only/ca-slope.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: data/ca-prod-slope.h5\n#| requires: src/CaProd.jl\n\nmodule Script\nusing CarboKitten.BoundaryTrait: Shelf\nusing CarboKitten.Config: Box, TimeProperties\nusing CarboKitten.Burgess2013.Config: MODEL1\nusing CarboKitten.CaProd\nusing Unitful\n\nconst DEFAULT_INPUT = CaProd.Input(\n  box = Box{Shelf}(\n    grid_size = (100, 50),\n    phys_scale = 0.15u\"km\"\n  ),\n  time = TimeProperties(\n    Œît = 0.001u\"Myr\",\n    steps = 1000,\n    write_interval = 1\n  ),\n  sea_level=_ -> 0.0u\"m\",\n  subsidence_rate=50.0u\"m/Myr\",\n  initial_depth=x -> x / 300.0,\n  facies=MODEL1,\n  insolation=400.0u\"W/m^2\"\n)\nend\n\nScript.CaProd.main(Script.DEFAULT_INPUT, \"data/ca-prod-slope.h5\")","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/production-only/plot-cap-slope.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: docs/src/fig/b13-crosssection.png\n#| requires: data/ca-prod-slope.h5 ext/VisualizationExt.jl\n#| collect: figures\n\nmodule Script\nusing CairoMakie\nusing CarboKitten.Visualization\n\nfunction main()\n    f = Figure()\n    plot_crosssection(f[1, 1], \"data/ca-prod-slope.h5\")\n    save(\"docs/src/fig/b13-crosssection.png\", f)\nend\nend\n\nScript.main()","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"(Image: Stratigraphy; production and subsidence.)","category":"page"},{"location":"ca-with-production/#Visualizing-output","page":"Model with CA and Production","title":"Visualizing output","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>src/Visualization.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"module Visualization\n    export plot_crosssection, plot_facies_production\n\n    print_instructions() = print(\"You'll need to import both Makie and GeometryBasics before using this.\\n\")\n\n    function plot_facies_production(args...)\n        print_instructions()\n    end\n\n    function plot_crosssection(args...)\n        print_instructions()\n    end\nend  # module","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>ext/VisualizationExt.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"module VisualizationExt\n\nusing CarboKitten\nusing CarboKitten.Visualization\nusing CarboKitten.Burgess2013: production_rate\n\nusing HDF5\nusing Makie\nusing GeometryBasics\nusing Unitful\n\nfunction CarboKitten.Visualization.plot_facies_production(input; loc = nothing)\n fig, loc = isnothing(loc) ? let fig = Figure(); (fig, fig[1, 1]) end : (nothing, loc)\n ax = Axis(loc, title=\"production at $(sprint(show, input.insolation; context=:fancy_exponent=>true))\", xlabel=\"production (m/Myr)\", ylabel=\"depth (m)\", yreversed=true)\n for f in input.facies\n  depth = (0.1:0.1:50.0)u\"m\"\n  prod = [production_rate(input.insolation, f, d) for d in depth]\n  lines!(ax, prod / u\"m/Myr\", depth / u\"m\")\n\n end\n fig\nend\n\nfunction CarboKitten.Visualization.plot_crosssection(pos, datafile)\n    # x: 1-d array with x-coordinates\n    # t: 1-d array with time-coordinates (n_steps + 1)\n    # h[x, t]: height fn, monotonic increasing in time\n    # p[x, facies, t]: production rate\n    # taken at y = y_max / 2, h[x, 1] is initial height\n    n_facies, x, t, h, p = h5open(datafile, \"r\") do fid\n        attr = HDF5.attributes(fid[\"input\"])\n        Œît = attr[\"delta_t\"][]\n        subsidence_rate = attr[\"subsidence_rate\"][]\n        t_end = fid[\"input/t\"][end-1]\n        total_subsidence = subsidence_rate * t_end\n        total_sediment = sum(fid[\"sediment\"][]; dims=3)\n        initial_height = fid[\"input/height\"][]\n        center = div(size(total_sediment)[1], 2)\n        elevation = cumsum(total_sediment; dims=4)[:, center, 1, :] .* Œît .- initial_height .- total_subsidence\n        t = fid[\"input/t\"][]\n        n_facies = size(fid[\"sediment\"])[3]\n\n        return n_facies,\n        fid[\"input/x\"][],\n        [t; Œît * attr[\"time_steps\"][]],\n        hcat(.-initial_height .- total_subsidence, elevation),\n        fid[\"sediment\"][:, center, :, :]\n    end\n\n    pts = vec(Point{2,Float64}.(x, h[:, 2:end]))\n    c = vec(argmax(p; dims=2)[:, 1, :] .|> (c -> c[2]))\n    rect = Rect2(0.0, 0.0, 1.0, 1.0)\n    m_tmp = GeometryBasics.mesh(Tesselation(rect, (100, 1000)))\n    m = GeometryBasics.Mesh(pts, faces(m_tmp))\n\n    # pts = vec(Point{2,Float64}.(x, h))\n    # c = argmax(p; dims=2)[:,1,:] .|> (c -> c[2])\n    # w = size(x)[1]\n\n    # face(idx) = let k = idx[1] + idx[2]*w\n    #     TriangleFace(k, k+1, k+1+w), TriangleFace(k+1+w, k+w, k)\n    # end\n\n    ax = Axis(pos, xlabel=\"location\", ylabel=\"depth\", limits=((-12, x[end]), nothing))\n    # for f in 1:n_facies\n    #     locs = CartesianIndices((size(x)[1], size(t)[1] - 1))[c .== f]\n    #     triangles = collect(Iterators.flatten(face.(locs)))\n    #     m = GeometryBasics.Mesh(pts, triangles)\n    #     mesh!(ax, m)\n    # end\n\n    mesh!(ax, m, color=c, alpha=0.7)\n    for idx in [1, 501, 1001]\n        lines!(ax, x, h[:, idx], color=:black)\n        text!(ax, -2.0, h[1, idx]; text=\"$(t[idx]) Myr\", align=(:right, :center))\n    end\n    for idx in [250, 750]\n        lines!(ax, x, h[:, idx], color=:black, linewidth=0.5)\n    end\nend\n\nend","category":"page"},{"location":"stencils/#Stencil-operations","page":"Stencils","title":"Stencil operations","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"A stencil is the common term for computing many-to-one operations on grids. Examples of applications are:","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Finite difference schemes\nFinite Impulse Response (FIR) filters\nConvolutions (encompassing the previous two)\nCellular Automata","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Note that for larger convolution kernels, it is often more efficient to perform convolutions in the Fourier domain. On the matter of performance: stencil operations are the textbook example for computations that perform really well on GPUs.","category":"page"},{"location":"stencils/#Implementation","page":"Stencils","title":"Implementation","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Using these helper functions we can now define a stencil operation. Given the boundary trait, a stencil size and a response function, we can transform an array to a next generation.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<div class=\"noweb-label\">‚™°stencil-operation‚™¢‚â£</div>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"function stencil(::Type{T}, ::Type{BT}, n::NTuple{dim,Int}, f::Function) where {T, dim, BT <: Boundary{dim}}\n    m = n .√∑ 2\n    stencil_shape = range.(.-m, m)\n    stencil = zeros(T, n)\n\n    function(z_in::AbstractArray{T, dim}, z_out::AbstractArray{T, dim}, args...)\n        @assert (size(z_in) == size(z_out)) \"sizes of arrays need to be equal\"\n        shape = size(z_in)\n        Threads.@threads for i in CartesianIndices(shape)\n            for (k, Œîi) in enumerate(CartesianIndices(stencil_shape))\n                stencil[k] = offset_value(BT, z_in, i, Œîi)\n            end\n            z_out[i] = f(stencil, args...)\n        end\n    end\nend\n\nfunction convolution(::Type{B}, kernel::Array{T, dim}) where { dim, T, B <: Boundary{dim} }\n    stencil(T, B, size(kernel), s -> sum(s .* kernel))\nend","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"More efficient implementations are imaginable. For instance we could use normal unchecked indexing for most of the array, and only use the offset_value function when we really need it. Another optimisation could be to generate parts of the inner loop, and/or do the outer loop in parallel.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"We will now test this function first on an Elementary CA (ECA), Conway's Game of Life, and a convolution.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<details><summary>Stencil module</summary>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<div class=\"noweb-label\">file:<i>src/Stencil.jl</i></div>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"module Stencil\n\nusing ..Config: AbstractBox\nusing ..BoundaryTrait\n\nexport stencil, convolution\n\n<<stencil-operation>>\n\nend","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"</details>","category":"page"},{"location":"stencils/#Examples","page":"Stencils","title":"Examples","text":"","category":"section"},{"location":"stencils/#Elementary-Cellular-Automata","page":"Stencils","title":"Elementary Cellular Automata","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"An Elementary Cellular Automata is a one-dimensional CA with two states. Every next generation depends on the direct neighbourhood of three cells. Since there are 2^3 = 8 patterns and two outcomes for every pattern, there are 2^8 = 256 possible ECA.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<div class=\"noweb-label\">file:<i>examples/ca/eca.jl</i></div>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"#| creates: docs/src/fig/eca.png\n#| requires: src/Stencil.jl\n#| collect: figures\n\nmodule ECA\n    using CarboKitten.BoundaryTrait\n    using CarboKitten.Stencil\n    using CairoMakie\n\n    rule(i::Int) = function (foo::AbstractVector{T}) where T <: Integer\n        d = foo[1]*4 + foo[2]*2 + foo[3]\n        i & (1 << d) == 0 ? 0 : 1\n    end\n\n    function eca(r::Int, n::Int, iter::Int)\n        y = Array{Int}(undef, n, iter)\n        y[:, 1] = zeros(Int, n)\n        y[div(n, 2), 1] = 1\n        stencil_op = stencil(Int, Periodic{1}, (3,), rule(r))\n        for i in 2:iter\n            stencil_op(view(y, :, i-1), view(y, :, i))\n        end\n        y\n    end\n\n    function plot()\n        fig = Figure(size=(1200,400))\n        for (idx, r) in enumerate([18, 30, 110])\n            ax = Axis(fig[1,idx]; title=\"rule $(r)\", yreversed=true, limits=((1, 256), (1, 128)))\n            heatmap!(ax, eca(r, 256, 128); colormap=:Blues)\n        end\n        save(\"docs/src/fig/eca.png\", fig)\n    end\nend\n\nECA.plot()","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"(Image: )","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Even these one-dimensional CA show highly complex behaviour. For instance, it has been shown that rule 110 is Turing complete.","category":"page"},{"location":"stencils/#Game-of-Life","page":"Stencils","title":"Game of Life","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Perhaps the most famous CA is Conway's Game of Life. This is a two-dimensional two-state (dead/alive) CA, with the following rules: a cell is alive in the next generation if it is alive and has two neighbours or if it has three neighbours; in all other cases the cell is dead.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<div class=\"noweb-label\">file:<i>examples/ca/life.jl</i></div>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"#| creates: docs/src/fig/life.gif\n#| requires: src/Stencil.jl\n#| collect: figures\n\nmodule Life\n    using CarboKitten.BoundaryTrait\n    using CarboKitten.Stencil\n    using GLMakie\n    using .Iterators: take\n\n    \"x is a 3x3 region around the cell at x[2,2].\"\n    rules(x) = let c = x[2, 2], s = sum(x) - c\n        c && s == 2 || s == 3\n    end\n\n    function game_of_life(w, h)\n        y1 = rand(Bool, (w, h))\n        y2 = Array{Bool}(undef, w, h)\n\n        op = stencil(Bool, Periodic{2}, (3, 3), rules)\n        Channel() do ch\n            put!(ch, y1)\n            while true\n                op(y1, y2)\n                (y1, y2) = (y2, y1)\n                put!(ch, y1)\n            end\n        end\n    end\n\n    function plot()\n        life = take(game_of_life(50, 50), 150)\n        fig = Figure()\n        ax = Axis(fig[1,1], aspect=1)\n        record(fig, \"docs/src/fig/life.gif\", life; framerate=10) do frame\n            heatmap!(ax, frame; colormap=:Blues)\n        end\n    end\nend\n\nLife.plot()","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"(Image: )","category":"page"},{"location":"stencils/#Testing-boundaries-with-a-convolution","page":"Stencils","title":"Testing boundaries with a convolution","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"To test the different boundary types, lets try the following setup. We take a 16x16 image with all zeros except the bottom left gets a value of 1 and the top right pixel gets a value of 2. Now convolve with a Gaussian and see what happens. For the constant boundary, I've set the value to 0.1, to see the effect.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"(Image: )","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Notice, that for the periodic boundaries, the bottom left and top right are neighbouring. So there the two pixels appear as a single peak. In the reflected case we see a clear distinction between the two corners.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"#| creates: docs/src/fig/boundary_types.png\n#| requires: src/Stencil.jl\n#| collect: figures\n\nmodule Script\n\nusing CarboKitten.BoundaryTrait\nusing CarboKitten.Stencil\nusing CairoMakie\n\nfunction plot_boundary_types()\n    n = 16\n    y0 = zeros(Float64, n, n)\n    y0[1, 1] = 1\n    y0[n, n] = 2\n    x = collect(-2:0.25:2)\n    k = exp.(-(x.^2 .+ x'.^2))\n    k ./= sum(k)\n\n    y_periodic = Array{Float64}(undef, n, n)\n    convolution(Periodic{2}, k)(y0, y_periodic)\n    y_reflected = Array{Float64}(undef, n, n)\n    convolution(Reflected{2}, k)(y0, y_reflected)\n    y_constant = Array{Float64}(undef, n, n)\n    convolution(Constant{2, 0.1}, k)(y0, y_constant)\n\n    fig = Figure(size=(900, 300))\n    for (i, y) in enumerate([y_periodic, y_reflected, y_constant])\n        ax = Axis(fig[1,i]; aspect=1)\n        heatmap!(ax, y; colormap=:viridis)\n    end\n    save(\"docs/src/fig/boundary_types.png\", fig)\nend\nend \n\nScript.plot_boundary_types()","category":"page"},{"location":"#CarboKitten.jl:-Modeling-Carbonate-Platforms-in-Julia","page":"Introduction","title":"CarboKitten.jl: Modeling Carbonate Platforms in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Entangled badge)","category":"page"},{"location":"#About","page":"Introduction","title":"About","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CarboKitten is a clone of Peter Burgess' CarboCAT, a model for growing carbonate platforms.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Sample output stratigraphy)","category":"page"},{"location":"#Julia-Quickstarter","page":"Introduction","title":"Julia Quickstarter","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This code is written in Julia. You may want to check out the following references:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia Documentation\nTutorial on Julia for Science and Engineering","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are several ways to work with Julia that may be a bit different from what you're used to, if that is Matlab, Python or R.","category":"page"},{"location":"#Installing-Julia","page":"Introduction","title":"Installing Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The best way to install Julia is to use juliaup at github.com/JuliaLang/juliaup.","category":"page"},{"location":"#REPL","page":"Introduction","title":"REPL","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The most basic way to work in Julia, is to start the REPL (Read Eval Print Loop).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.3 (2023-08-24)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"From here you may use CarboKitten using CarboKitten and run any of the code inside. To work with CarboKitten efficiently, you may want to load Revise. Revise auto-detects changes to loaded code and makes it easy to rerun.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Additionally you should learn how to work with Julia packages. If you want to experiment with things, try to create a new environment in an empty folder and add CarboKitten as a dev dependency:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> dev <path to CarboKitten>","category":"page"},{"location":"#VS-Code","page":"Introduction","title":"VS Code","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"VSCode has very good support for working with Julia. Install the official Julia plugin and you should be good to go. Explore options by pressing Ctrl+Shift+P and type Julia to see what you can do. For example: start a REPL, run current script etc.","category":"page"},{"location":"#Jupyter","page":"Introduction","title":"Jupyter","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"You can run Julia code from Jupyter if you install the Julia kernel. Press ] in the REPL to get into Pkg-mode, the prompt will change","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(CarboKitten) pkg>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You may install the IJulia kernel with add IJulia.","category":"page"},{"location":"#Pluto","page":"Introduction","title":"Pluto","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An alternative notebook interface is called Pluto.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pluto is reactive: changes to code cells automatically update downstream dependencies.\nPluto notebooks are written to regular Julia files and can be run independent from Pluto.\nThe user interface of Pluto is slightly less mature than Jupyter","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In Pkg-mode say add Pluto.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pluto\n\njulia> Pluto.run()\n[ Info: Loading...\n‚îå Info: \n‚îî Opening http://localhost:1234/?secret=xyzxyzzy in your default browser... ~ have fun!\n‚îå Info: \n‚îÇ Press Ctrl+C in this terminal to stop Pluto\n‚îî ","category":"page"},{"location":"#Plotting","page":"Introduction","title":"Plotting","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The most used library to do plotting in Julia is called Plots. However, this library comes with a fair share of problems: there are a number of back-ends for which the generated plots may look slightly different. Here \"back-end\" means some plotting library written in a different language than Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A nicer plotting library that also happens to be a bit more versatile is Makie. This has three back-ends that are CairoMakie, GLMakie and WGLMakie. These are all written in Julia, but they focus on different kinds of results. CairoMakie is usually slow but results in publication quality vector graphics: SVG or PDF. GLMakie is very fast, renders on your graphics card, but only produces raster images, say PNG. Then WGLMakie does a similar thing, but through the web-browser.","category":"page"},{"location":"#Entangled","page":"Introduction","title":"Entangled","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you plan to make a contribution to the core of CarboKitten, you should be aware of Entangled.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation for CarboKitten is using Entangled for Literate Programming. This means that code blocks in the documentation contribute to the actual functioning code in the library. When you develop the library code, you should have the Entangled daemon running to keep the documentation synchronized. Included in the CarboKitten repository is a pyproject.toml that manages the Entangled installation for you through Poetry; alternatively, you may install Entangled through pip install entangled-cli.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To install, run poetry install in the project root, then:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"poetry run entangled watch","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Entangled is still under development and it may occur that the daemon complains about not knowing wether to tangle or stitch, for example when you've accidentally written both markdown and source code. If this happens you may manually entangled tangle or entangled stitch with the --force argument to decide the issue. It may be worth saving your work in version control before doing so.","category":"page"},{"location":"#Building-Documentation","page":"Introduction","title":"Building Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To recreate the plots in the documentation run","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"poetry run brei figures","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation can be rendered with Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia --workenv=docs docs/make.jl","category":"page"},{"location":"#Project-structure","page":"Introduction","title":"Project structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":".\n‚îú‚îÄ‚îÄ data                # data files\n‚îú‚îÄ‚îÄ docs                # documentation\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ make.jl         # docs build script\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Manifest.toml   # \n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Project.toml    # dependencies for building docs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ src             # markdown source for docs\n‚îú‚îÄ‚îÄ entangled.toml      # entangled config\n‚îú‚îÄ‚îÄ examples            # example scripts\n‚îú‚îÄ‚îÄ Makefile            # command-line short hands\n‚îú‚îÄ‚îÄ Manifest.toml       #\n‚îú‚îÄ‚îÄ Project.toml        # project dependencies\n‚îú‚îÄ‚îÄ pyproject.toml      # dependencies for running Entangled\n‚îú‚îÄ‚îÄ README.md           # \n‚îú‚îÄ‚îÄ src                 # tangled library source\n‚îî‚îÄ‚îÄ test                # unit tests","category":"page"},{"location":"#Authors","page":"Introduction","title":"Authors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Lead engineer: Johan Hidding   Netherlands eScience Center   email: j.hidding [at] esciencecenter.nl Web page: www.esciencecenter.nl/team/johan-hidding-msc/   ORCID: 0000-0002-7550-1796","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Original author: Peter Burgess   University of Liverpool   Web page: www.liverpool.ac.uk/environmental-sciences/staff/peter-burgess","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Project lead: Emilia Jarochowska   Utrecht University   email: e.b.jarochowska [at] uu.nl   Web page: www.uu.nl/staff/EBJarochowska   ORCID: 0000-0001-8937-9405","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Other team members:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Niklas Hohmann   Utrecht University   email: n.h.hohmann [at] uu.nl   Web page: www.uu.nl/staff/NHohmann   ORCID: 0000-0003-1559-1838","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Xianyi Liu   Utrecht University   email: x.liu6 [at] uu.nl   Web page: www.uu.nl/staff/XLiu6   ORCID:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Hanno Spreeuw   Netherlands eScience Center   email: h.spreeuw [at] esciencecenter.nl   Web page: www.esciencecenter.nl/team/dr-hanno-spreeuw/   ORCID: 0000-0002-5057-0322","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"David De Vleeschouwer   Westf√§lische Wilhelms-Universit√§t M√ºnster   Web page: www.uni-muenster.de/GeoPalaeontologie/erdsystemforschung/staff/DeVleeschouwer   ORCID: 0000-0002-3323-807X","category":"page"},{"location":"#Copyright","page":"Introduction","title":"Copyright","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Copyright 2023 Netherlands eScience Center and Utrecht University","category":"page"},{"location":"#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Apache 2.0 License, see LICENSE file for license text.","category":"page"},{"location":"#Funding-information","page":"Introduction","title":"Funding information","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Funded by the European Union (ERC, MindTheGap, StG project no 101041077). Views and opinions expressed are however those of the author(s) only and do not necessarily reflect those of the European Union or the European Research Council. Neither the European Union nor the granting authority can be held responsible for them.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
